\documentclass[a4paper,12pt]{report}
% Alternative Options:
%	Paper Size: a4paper / a5paper / b5paper / letterpaper / legalpaper / executivepaper
% Duplex: oneside / twoside
% Base Font Size: 10pt / 11pt / 12pt

\usepackage[export]{adjustbox}

\usepackage{geometry}
%% Language %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage[USenglish]{babel} %francais, polish, spanish, ...
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

\usepackage{verbatim}
\usepackage{lmodern} %Type1-font for non-english texts and characters


%% Packages for Graphics & Figures %%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx} %%For loading graphic files
%\usepackage{subfig} %%Subfigures inside a figure
%\usepackage{pst-all} %%PSTricks - not useable with pdfLaTeX

%% Please note:
%% Images can be included using \includegraphics{Dateiname}
%% resp. using the dialog in the Insert menu.
%% 
%% The mode "LaTeX => PDF" allows the following formats:
%%   .jpg  .png  .pdf  .mps
%% 
%% The modes "LaTeX => DVI", "LaTeX => PS" und "LaTeX => PS => PDF"
%% allow the following formats:
%%   .eps  .ps  .bmp  .pict  .pntg


%% Math Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}


%% Line Spacing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{setspace}
%\singlespacing        %% 1-spacing (default)
%\onehalfspacing       %% 1,5-spacing
%\doublespacing        %% 2-spacing
\usepackage{listings}
\lstset{language=C++} 
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C++,                 % the language of the code
  otherkeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}







%% NOTE POUR CLEMENT : UTILISE LE HEADER CI-DESSUS, IL EST MEILLEUR

%%AJOUTS DE CLEMENT DANS LE HEADER :
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Clément BLANQUET et Rafik CHENNOUF}
\rhead{Page \thepage}
\cfoot{\footnotesize{MI11 - Rapport des TPs : Réalisation d'un mini noyau temps réel}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\usepackage{titlesec}
\makeatletter
\titleformat{\chapter}[frame]
  {\normalfont}{\filright\enspace \@chapapp~\thechapter\enspace}
  {15pt}{\LARGE\bfseries\filcenter}
\titlespacing*{\chapter}
  {0pt}{0pt}{20pt}
\makeatother

\renewcommand{\thesection}{}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\makeatletter
\def\@seccntformat#1{\csname #1ignore\expandafter\endcsname\csname the#1\endcsname\quad}
\let\sectionignore\@gobbletwo
\let\latex@numberline\numberline
\def\numberline#1{\if\relax#1\relax\else\latex@numberline{#1}\fi}
\makeatother

\usepackage{animate}
\usepackage{hyperref}




\author{Clément BLANQUET et Rafik CHENNOUF}
\title{MI11 - Rapport des TPs : Réalisation d'un mini noyau temps réel}

\begin{document}

\begin{titlepage}

	\centering
	\includegraphics[width=0.15\textwidth]{sigle_UTC.jpg}\par\vspace{1cm}
	{\scshape\LARGE Université de Technologie de Compiègne \par\vspace{1cm}}	
	{\scshape\Large MI11\par}
	\vspace{1.5cm}
	{\huge\bfseries Rapport des TPs : Réalisation d'un mini noyau temps réel\par}
	\vspace{2cm}
	{\Large\itshape Clément BLANQUET et Rafik CHENNOUF\par}
	\vspace{2cm}
	\vfill
% Bottom of the page
	{\large Juin 2017}
\end{titlepage}


\renewcommand{\contentsname}{Sommaire} % Changer le nom de la table des matieres
\tableofcontents
% Les différentes tables
\listoffigures        % Liste des figures




\chapter{Rapport TP 2 - Partie 3 et 4}

Le but de ce TP est d'implémenter des fonctions d'exclusions mutuelles afin que plusieurs tâches ne puissent pas accéder à une section critique en même temps au risque de créer un interblocage.  


\section{Exercice 1 : Exclusion mutuelle}

Tout d'abord, il est possible de faire du partage de ressources en agissant directement sur les tâches dépendantes en les faisant s'endormir ou se réveiller selon la situation. Dès qu'une tâche a terminée son accès à la mémoire partagée elle s'endort et réveille l'autre tâche afin qu'elle puisse y avoir accès et vis-versa.

\subsection{Suspension d'une tâche}

L'endormissement d'une tâche se fait via la primitive \textit{dort()} du fichier \textbf{noyau.c}.
Le but de cette fonction est de suspendre la tâche courante qui passe donc de l'état \textbf{EXEC} pour 'exécuter' à l'état \textbf{SUSP} pour 'suspendre'. La tâche est ensuite retirée de la file ds tâches et un appel à l'ordonnanceur est réalisé afin de charger la tâche suivante. De plus, toutes ces opérations constituent une section critique qui ne doivent pas être exécutées en même temps par plusieurs fonctions. C'est pour cela qu'il faut les protéger avec un \textit{mutex} ou un \textit{lock}.\newline

Ci-dessous le code de la fonction \textit{dort()} :

\begin{lstlisting}
void  dort(void)
{
	_lock_();				// section critique

	CONTEXTE *p = &_contexte[_tache_c];
	p->status = SUSP;	// suspension

	retire(_tache_c);	// retirer la tâche
	schedule();

	_unlock_();
}
\end{lstlisting}

\subsection{Réveil d'une tâche}

Le réveil d'une tâche se fait via la primitive \textit{reveille()} du fichier \textbf{noyau.c}.
Cette primitive fonctionne de la même manière que la fonction \textit{dort()} vue précédemment sauf que l'état de la tâche courante est passé en mode EXEC au lieu de SUSP afin que la tâche puisse être exécutable par l'ordonnanceur après l'avoir ajoutée dans la file.\newline

Ci-dessous le code de la fonction \textit{reveille()} :

\begin{lstlisting}
void reveille(uint16_t t)
{

	// on vérifie que la tâche existe et est suspendue
	if(t > MAX_TACHES || _contexte[t].status != SUSP)	 
		return;

	_lock_();		// section critique

	CONTEXTE *p = &_contexte[t];
	p->status = EXEC;		// exécution

	ajoute(t);		// ajout dans la file
	schedule();

	_unlock_();
}
\end{lstlisting}

\subsection{Modèle de communications producteur/consommateur.}

Afin de tester nos deux primitives \textit{dort()} et \textit{reveille()}, nous avons implémenté le modèle de communications producteur/consommateur. Tout d'abord le programme comporte deux tâches; la première, le producteur, produit des entiers dans une file circulaire, la seconde, le consommateur, retire ces entiers de la file et les affiche.\newline

Pour faire cela, nous disposons d'une FIFO sous forme d'un tableau d'entiers de taille fixée (3 dans notre cas). On distingue 4 cas possibles :

1) Le producteur a tellement produit que la file est pleine => il s'endort.
2) Le producteur a produit au moins un entier, la file est non vide => il réveille le consommateur pour qu'il consomme un ou des entiers.
3) La file est vide car le producteur n'y a rien produit => le consommateur s'endort.
4) Il reste encore de la place dans la file, la file est non pleine => le producteur se réveille pour produire des entiers.

Pour gérer tous ces cas, nous possédons une variable qui compte le nombre de places libres et qui est, au début du programme, initialisée à la taille du tableau. Lorsque le nombre de places libres est supérieur ou égal à 1, le producteur produit un entier dans la file puis décrémente le nombre de places libres. De même, si le nombre de places libres est inférieur à la taille totale de la file alors le consommateur consomme un entier puis incrémente le nombre de places libres.\newline
Le cas 1 se produit lorsque la file est pleine, c'est à dire lorsque le nombre de places libres est égal à 0. 
Le cas 2 se produit lorsque la file est non vide,  c'est à dire lorsque le nombre de places libres est inférieur à la taille totale de la file.
Le cas 3 se produit lorsque la file est vide,  c'est à dire lorsque le nombre de places libres est égal à la taille totale de la file.
Le cas 4 se produit lorsque la file est non pleine, c'est à dire lorsque le nombre de places libres est égal à 1.\newline

En résumé, le producteur produit des entiers dans la file tant que celle-ci n'est pas pleine sinon il s'endort et le consommateur lit ces entiers tant que la file n'est pas vide sinon il s'endort. Lorsqu'il y a la moindre place dans la file, le consommateur réveille le producteur et lorsqu'il y a le moindre entier dans la file, le producteur réveille le consommateur.
A noté aussi que l'accès à la file représente une zone critique qu'il faut protéger via un \textit{lock}.
Initialement, seul le producteur est réveillé et le consommateur est endormi car il faut pouvoir produire au moins un entier.\newline

Nous avons testé deux cas de figures, un cas où le producteur est plus rapide que le consommateur et le cas inverse.\newline

Ci-dessous le code du modèle de communications producteur/consommateur dans le cas où le consommateur est plus rapide que le producteur :

\begin{lstlisting}
#define TAILLE_TABLEAU 3	

TACHE tacheStart();
TACHE tacheProd();
TACHE tacheConso();
uint16_t prod, conso;
uint16_t fifo[TAILLE_TABLEAU];	// la file
uint16_t nb_places_libres = TAILLE_TABLEAU;

TACHE	tacheStart(void)		// tâche de démarrage
{
  puts("------> EXEC tache Start");
  prod = cree(tacheProd);
  conso = cree(tacheConso);

  active(prod);
  active(conso);

  fin_tache();
}

TACHE	tacheProd(void)		// tâche producteur
{
  puts("------> EXEC tache Prod");

  uint16_t j=0,k,i=0;

  while(1)
  {
	  for (k=0; k<30000; k++);		// producteur plus lent

	  if (nb_places_libres>=1)		// production d'un entier
	  {
		  _lock_();									// zone critique
		  printf("**PROD** -> Production : fifo[%d] = %d\n", i, j);
		  fifo[i]=j;
		  _unlock_();
		  j++;

		  nb_places_libres--;

		  i++;
		  if (i==TAILLE_TABLEAU)	// i = indice de la file
			  i=0;
	  }
	  else			// file pleine
	  {
		  _lock_();
		  puts("**PROD** -> Producteur dort (Cas 1 : File pleine)\n");
		  _unlock_();

		  dort();		// producteur s'endort
	  }

	  if (nb_places_libres<TAILLE_TABLEAU)	// file non vide
	  {
		  _lock_();
		  puts("**PROD** -> Reveil du conso (Cas 2 : File non vide)\n");
		  _unlock_();

		  reveille(conso);		// consommateur se réveille
	  }

  }

  fin_tache();
}

TACHE	tacheConso(void)		// tâche consommateur
{
  uint16_t k,i=0;

  puts("------> EXEC tache Conso");

  dort();		// consommateur dort initialement

  while(1)
  {
	  for (k=0; k<10000; k++);	// consommateur plus rapide

	  if (nb_places_libres==TAILLE_TABLEAU)	// file vide
	  {
		  _lock_();
		  puts("**CONSO** -> Consommateur dort (Cas 3 : File vide)\n");
		  _unlock_();

		  dort();		// consommateur s'endort
	  }
	  else
	  {
		  _lock_();
		  printf("**CONSO** -> Lecture de fifo[%d] = %d\n", i, fifo[i]);
		  _unlock_();

		  nb_places_libres++;

		  i++;
		  if (i==TAILLE_TABLEAU)	// i = indice de la file
			  i=0;
	  }

	  if (nb_places_libres==1)	// file non pleine
	  {
		  _lock_();
		  puts("**CONSO** -> Reveil prod (Cas 4 : File non pleine)\n");
		  _unlock_();

		  reveille(prod);		// producteur se réveille
	  }
  }

  fin_tache();
}

int main()
{
  serial_init(115200);
  puts("Test noyau");
  puts("Noyau preemptif");
  puts("*******************DEBUT*********************\n\n\n\n\n");

  printf("TAILLE DU TABLEAU : %d\n", TAILLE_TABLEAU);

  start(tacheStart);
  return(0);
}
\end{lstlisting}

Le résultat obtenu lorsque le consommateur est plus rapide que le producteur est donné sur la figure \ref{conso_plus_rapide}.\newline

Initialement, le producteur écrit l'entier 0 à la case 0 de la file puis il réveille le consommateur (Cas 2 : file non vide). Le consommateur qui est très rapide s'empresse aussitôt de lire l'entier 0 à la case 0 puis s'endort (Cas 3 : file vide). Ensuite, le producteur écrit l'entier 1 à la case 1 de la file puis il réveille le consommateur pour qu'il lise cet entier.\\
Comme le consommateur est plus rapide que le producteur, nous obtenu une succession d'écriture/lecture. Dès qu'un entier est présent dans la file, le consommateur le lit. Cliquez sur l'animation suivante pour voir le résultat de notre programme (nécessite de lire ce PDF avec Adobe Acrobat Reader) :

\begin{figure}[h]
	  \centering
  	\animategraphics{1}{animations/conso_plus_rapide/prod-}{1}{12}
		\caption{Consommateur plus rapide que le producteur}
		\label{anim_conso_plus_rapide}
\end{figure}

\newpage

Nous pouvons aussi tester le cas où le producteur est plus rapide que le consommateur (figure \ref{prod_plus_rapide}).\newline

Dans ce cas, le producteur enchaîne deux écritures à la suite (entier 0 à la case 0 et entier 1 à la case 1) car il est plus rapide que le consommateur qui n'a pas le temps de lire le premier entier. Après cela, le consommateur peut enfin lire l'entier 0 à la case 0 puis le producteur reprend la main et enchaîne de nouveau deux écritures (entier 2 à la case 2 et entier 3 à la case 0). Le consommateur se réveille et lit donc l'entier 1 à la case 1, on se retrouve donc dans le cas 4 (file non pleine). Le producteur reprend la main et écrit l'entier 4 à la case 1 qui vient d'être libérée par le consommateur puis il s'endort (Cas 1 : file pleine). Le producteur aura toujours une longueur d'avance sur le consommateur et sera souvent endormi à cause d'une file pleine. Cliquez sur l'animation suivante pour voir le résultat de notre programme (nécessite de lire ce PDF avec Adobe Acrobat Reader) :

\begin{figure}[h]
	\centering
		\animategraphics{1}{animations/prod_plus_rapide/prod-}{1}{15}
		\caption{Producteur plus rapide que le consommateur}
		\label{anim_conso_plus_rapide}
\end{figure}

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=0.4\textwidth]{screens/conso_plus_rapide_sem.png}
		\caption{Consommateur plus rapide que le producteur}
		\label{conso_plus_rapide}
\end{figure}

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=0.4\textwidth]{screens/prod_plus_rapide_sem.png}
		\caption{Producteur plus rapide que le consommateur}
		\label{prod_plus_rapide}
\end{figure}

\newpage

La méthode d'exclusion mutuelle présentée précédemment avec endormissement et réveil des tâches peut poser problème dans le cas général. En effet, nous ne sommes pas à l'abri d'un interblocage des deux tâches si elles sont toutes les deux endormies et qu'elles attendent d'être réveillées. Ceci peut arriver puisque rien ne garantit qu'un signal de réveil ne soit pas interrompue. Une première tâche pourrait en principe envoyer son signal de réveil avant que la seconde tâche s'endorme ce qui engendrerait une attente infinie.

\section{Exercice 2 : Sémaphores}

Un deuxième outil plus efficace que le précédent pour gérer les problèmes de ressources partagées repose sur les sémaphores. Ce mécanisme permet de gérer l'envoi des signaux indépendamment de l'exécution des tâches.

\subsection{Implémentation}

Un sémaphore est composé d'une FIFO de tâches en attente et d'une valeur représentant le nombre de ressources disponibles. Une FIFO est une structure circulaire composée d'une file de tâches, de l'indice de début de la file et de l'indice de fin de la file. Dans cet exercice, nous considérons un tableau de sémaphores. Ci-dessous le fichier header \textit{sem.h} :\newline

\begin{lstlisting}
#ifndef SEM_H_
#define SEM_H_

#include <stdint.h>

#define MAX_SEM 15

typedef struct {
  short taches[MAX_TACHES];
  short debut_file;	
  short fin_file;
} FIFO;

typedef struct {
	FIFO file;     // File circulaire des tâches en attente 
	short valeur ; // compteur du sémaphore e(s) 
} SEMAPHORE ;

void s_init( void );
ushort s_cree( short v );
void s_close( ushort n );
void s_wait( ushort n );
void s_signal ( ushort n );

#endif /* SEM_H_ */
\end{lstlisting}


Un sémaphore se manipule via les cinq fonctions suivantes : \textit{s\_init}, \textit{s\_cree}, \textit{s\_close}, \textit{s\_wait} et \textit{s\_signal}, toutes définies dans le fichier \textbf{sem.c}.\newline

Tout d'abord la fonction \textit{s\_init} permet d'initialiser la valeur de notre tableau de sémaphores. Ici, nous avons choisi d'initialiser toutes nos sémaphores à -1000, nombre que nous considérons, dans cet exercice, inatteignable.\newline

\begin{lstlisting}
SEMAPHORE _sem[MAX_SEM];

void s_init( void )
{
	int i;

	for(i = 0; i < MAX_SEM; i++)
	{
		_sem[i].valeur = -1000;		// non crée
	}
}
\end{lstlisting}

La seconde fonction \textit{s\_cree} nous sert à créer un sémaphore et à l'initialiser à une certaine valeur donnée.\newline

\begin{lstlisting}
ushort s_cree( short v )
{
	int i = 0;

  // si la valeur du sémaphore dépasse le nombre de tâches
	if (v >= MAX_TACHES) 
		return -1;			

	// on cherche un emplacement libre
	while(i<MAX_SEM && _sem[i].valeur != -1000)	
		i++;

	if(i >= MAX_SEM)	// si on n'a pas trouver d'emplacement libre
		return -1;			

	// initialisation du sémaphore à la valeur v
	_sem[i].valeur = v;	
	_sem[i].file.debut_file = 0;	
	_sem[i].file.fin_file = 0;

	return i;
}
\end{lstlisting}

La troisième fonction \textit{s\_close} réinitialise une sémaphore donnée. La valeur du sémaphore est remise à -1000 pour qu'on le considère non crée.\newline

\begin{lstlisting}
void s_close( ushort n )
{
	if(n >= MAX_SEM || n < 0)
		return;

	_sem[n].valeur = -1000;
}
\end{lstlisting}

La fonction \textit{s\_wait} implémente l'opération P qui permet de prendre une ressource associée au sémaphore. On décrémente donc la valeur du sémaphore et si celle-ci est strictement inférieure à 0 alors on bloque/endort la tâche ayant effectué la requête et on la met dans la file des tâches en attente associée au sémaphore. Dans notre fonction les tâches sont ajoutées en fin de file.\newline

\begin{lstlisting}
void s_wait( ushort n )
{
	if(n >= MAX_SEM || n < 0)
		return;

	// si le sémaphore n'est pas crée
	if(_sem[n].valeur == -1000)
		return;

	// zone critique car plusieurs tâches ne doivent pas modifier le sémaphore en même temps
	_lock_();			

	_sem[n].valeur--;				// décrémentation du sémaphore

	if(_sem[n].valeur < 0)
	{
		// on ajoute la tâche courante à la fin de la file
		_sem[n].file.taches[_sem[n].file.fin_file] = _tache_c;	
			
		// incrémente la fin de la file
		_sem[n].file.fin_file = _sem[n].file.fin_file + 1;	
			
		// on met à jour la fin de la file circulaire
		// si fin_file < MAX_TACHES alors on ne change rien sinon on revient au début de la file
		_sem[n].file.fin_file = (_sem[n].file.fin_file) % MAX_TACHES; 

		dort();	// la tâche courante s'endort
	}

	_unlock_();
}
\end{lstlisting}

Enfin, la fonction \textit{s\_signal} implémente l'opération V qui permet de libérer une ressource associée au sémaphore. On incrémente donc la valeur du sémaphore et si celle-ci est inférieure ou égale à 0 alors on extrait une tâche de la file des tâches en attente et on la libère/réveille. Dans notre fonction les tâches sont extraites au début de file.\newline

\begin{lstlisting}
void s_signal ( ushort n )
{
	short tache;

	if(n >= MAX_SEM || n < 0)
		return;

	// si le sémaphore n'est pas crée
	if(_sem[n].valeur == -1000)		
		return;

	// zone critique car plusieurs tâches ne doivent pas modifier le sémaphore en même temps
	_lock_();						

	_sem[n].valeur++;				// incrémentation du sémaphore

	if(_sem[n].valeur <= 0)
	{
		// on extrait une tâche au début de la file
		tache = _sem[n].file.taches[_sem[n].file.debut_file]; 	
		
		// incrémente le début de la file
		_sem[n].file.debut_file = _sem[n].file.debut_file + 1;		
		
		// on met à jour le début de la file circulaire
		// si debut_file < MAX_TACHES alors on ne change rien sinon on va à la fin de la file
		_sem[n].file.debut_file = (_sem[n].file.debut_file) % MAX_TACHES; 

		reveille(tache);	// réveil de la tâche
	}

	_unlock_();
}
\end{lstlisting}

\subsection{Producteur/Consommateur}

Afin de tester nos sémaphores, nous avons ré-implémenté le problème du producteur/consommateur en remplaçant les primitives \textit{dort()} et \textit{reveille()} par respectivement \textit{s\_wait} et \textit{s\_signal}. Nous mettons en place deux sémaphores associés respectivement au producteur et au consommateur qu'on initialise à 0. Ceci permet au producteur d'être bloqué si la file est pleine et au consommateur d'être réveillé si il y a un entier à consommer. Le principe reste exactement le même que dans l'exercice précédent. 

\begin{lstlisting}
#define TAILLE_TABLEAU 3	

TACHE tacheStart();
TACHE tacheProd();
TACHE tacheConso();
uint16_t prod, conso;
uint16_t fifo[TAILLE_TABLEAU];	// la file
uint16_t nb_places_libres = TAILLE_TABLEAU;
ushort sem1, sem2;	// sem1 => producteur, sem2 => consommateur

TACHE	tacheStart(void)		// tâche de démarrage
{
  puts("------> EXEC tache Start");
  prod = cree(tacheProd);
  conso = cree(tacheConso);

  active(prod);
  active(conso);

  fin_tache();
}

TACHE	tacheProd(void)		// tâche producteur
{
  puts("------> EXEC tache Prod");

  uint16_t j=0,k,i=0;

  while(1)
  {
	  for (k=0; k<30000; k++);		// producteur plus lent

	  if (nb_places_libres>=1)		// production d'un entier
	  {
		  _lock_();									// zone critique
		  printf("**PROD** -> Production : fifo[%d] = %d\n", i, j);
		  fifo[i]=j;
		  _unlock_();
		  j++;

		  nb_places_libres--;

		  i++;
		  if (i==TAILLE_TABLEAU)	// i = indice de la file
			  i=0;
	  }
	  else			// file pleine
	  {
		  _lock_();
		  puts("**PROD** -> Producteur dort (Cas 1 : File pleine)\n");
		  _unlock_();

		  s_wait(sem1);			// dort()
	  }

	  if (nb_places_libres<TAILLE_TABLEAU)	// file non vide
	  {
		  _lock_();
		  puts("**PROD** -> Reveil du conso (Cas 2 : File non vide)\n");
		  _unlock_();

		  s_signal(sem2);		// reveille(conso);
	  }

  }

  fin_tache();
}

TACHE	tacheConso(void)		// tâche consommateur
{
  uint16_t k,i=0;

  puts("------> EXEC tache Conso");

  s_wait(sem2);			// dort()

  while(1)
  {
	  for (k=0; k<10000; k++);	// consommateur plus rapide

	  if (nb_places_libres==TAILLE_TABLEAU)	// file vide
	  {
		  _lock_();
		  puts("**CONSO** -> Consommateur dort (Cas 3 : File vide)\n");
		  _unlock_();

			s_wait(sem2);		// dort()
	  }
	  else
	  {
		  _lock_();
		  printf("**CONSO** -> Lecture de fifo[%d] = %d\n", i, fifo[i]);
		  _unlock_();

		  nb_places_libres++;

		  i++;
		  if (i==TAILLE_TABLEAU)	// i = indice de la file
			  i=0;
	  }

	  if (nb_places_libres==1)	// file non pleine
	  {
		  _lock_();
		  puts("**CONSO** -> Reveil prod (Cas 4 : File non pleine)\n");
		  _unlock_();

		  s_signal(sem1);			// reveille(prod);
	  }
  }

  fin_tache();
}

int main()
{
  serial_init(115200);
  puts("Test noyau");
  puts("Noyau preemptif");
  puts("*******************DEBUT*********************\n\n\n\n\n");

  printf("TAILLE DU TABLEAU : %d\n", TAILLE_TABLEAU);

  s_init();
  sem1 = s_cree(0);		// prod
  sem2 = s_cree(0);		// conso
  start(tacheStart);
	
  return(0);
}
\end{lstlisting}

Le résultat obtenu lorsque le consommateur est plus rapide que le producteur est exactement le même que sur la figure \ref{conso_plus_rapide}.
De même, dans le cas où le producteur est plus rapide que le consommateur, nous obtenons exactement le même résultat que dans la figure \ref{prod_plus_rapide}.\newline

\subsection{2 Producteurs/ 1 Consommateur}

Nous avons également testé nos sémaphores en ajoutant un producteur au problème précédent. Pour cela, il faut mettre en place un sémaphore binaire ou mutex qu'on initialise à 1 et qui empêche les deux producteurs de produire en même temps. On bloque le mutex avant production et on le libère après. De plus, il faut mettre en place des variables globales pour les indices et les valeurs de la file pour que les producteurs manipulent les mêmes données.\newline

\begin{lstlisting}
#define TAILLE_TABLEAU 3

TACHE tacheStart();
TACHE tacheProd1();
TACHE tacheProd2();
TACHE tacheConso();
uint16_t prod1, prod2, conso;		// 2 producteurs et 1 consommateur
uint16_t fifo[TAILLE_TABLEAU];
uint16_t nb_places_libres = TAILLE_TABLEAU;
ushort sem1, sem2, semMutexProd; 

// variables globales pour les producteurs
// l => indice de la file et j => valeur à cet indice
int l = 0, j = 0; 

TACHE	tacheStart(void)
{
  puts("------> EXEC tache Start");

  prod1 = cree(tacheProd1);
  prod2 = cree(tacheProd2);
  conso = cree(tacheConso);

  active(conso);
  active(prod1);
  active(prod2);

  fin_tache();
}

TACHE	tacheProd1(void)
{
  puts("------> EXEC tache Prod 1");

  uint16_t k;

  while(1)
  {
	  //for (k=0; k<30000; k++);
	  for (k=0; k<10000; k++);

	  s_wait(semMutexProd);	// P du mutex (entrée de la zone critique) 

	  if (nb_places_libres>=1)
	  {
		  _lock_();
		  printf("**PROD 1** -> Production : fifo[%d] = %d\n", l, j);
		  fifo[l]=j;
		  _unlock_();
		  j++;

		  nb_places_libres--;

		  l++;
		  if (l==TAILLE_TABLEAU)
			  l=0;
	  }
	  else
	  {
		  s_wait(sem1);		// dort()
	  }

	  s_signal(semMutexProd);// V du mutex (sortie de la zone critique)


	  if (nb_places_libres<TAILLE_TABLEAU)
	  {
		  s_signal(sem2);		// reveille(conso);
	  }

  }

  fin_tache();
}

TACHE	tacheProd2(void)
{
  puts("------> EXEC tache Prod 2");

  uint16_t k;

  while(1)
  {
	  //for (k=0; k<30000; k++);
	  for (k=0; k<10000; k++);

	  s_wait(semMutexProd); // P du mutex (entrée de la zone critique) 

	  if (nb_places_libres>=1)
	  {
		  _lock_();
		  printf("**PROD 2** -> Production : fifo[%d] = %d\n", l, j);
		  fifo[l]=j;
		  _unlock_();
		  j++;

		  nb_places_libres--;

		  l++;
		  if (l==TAILLE_TABLEAU)
			  l=0;
	  }
	  else
	  {
		  s_wait(sem1);		// dort()
	  }

	  s_signal(semMutexProd);// V du mutex (sortie de la zone critique)

	  if (nb_places_libres<TAILLE_TABLEAU)
	  {
		  s_signal(sem2);		// reveille(conso);
	  }

  }

  fin_tache();
}

TACHE	tacheConso(void)
{
  uint16_t k,i=0;

  puts("------> EXEC tache Conso");

  s_wait(sem2);	// dort()

  while(1)
  {
	  for (k=0; k<30000; k++);
	  //for (k=0; k<10000; k++);

	  if (nb_places_libres==TAILLE_TABLEAU)
	  {
		  s_wait(sem2);	// dort()
	  }
	  else
	  {
		  _lock_();
		  printf("**CONSO** -> Lecture de fifo[%d] = %d\n", i, fifo[i]);
		  _unlock_();

		  nb_places_libres++;

		  i++;
		  if (i==TAILLE_TABLEAU)
			  i=0;
	  }

	  if (nb_places_libres==1)
	  {
		  s_signal(sem1);	// reveille(prod);
	  }

  }

  fin_tache();
}

int main()
{
  serial_init(115200);
  puts("Test noyau");
  puts("Noyau preemptif");
  puts("*******************DEBUT*********************\n\n\n\n\n");

  printf("TAILLE DU TABLEAU : %d\n", TAILLE_TABLEAU);

  s_init();
  sem1 = s_cree(0);		// prod
  sem2 = s_cree(0);		// conso
	
	// mutex entre les 2 producteurs pour les empêcher de produire en même temps
  semMutexProd = s_cree(1);	
		
  start(tacheStart);

  return(0);
}
\end{lstlisting}

Nous avons testé deux configurations, l'une où les producteurs sont plus rapides que le consommateur et la deuxième où le consommateur est plus rapide que les producteurs. On suppose que les producteurs ont la même vitesse.\newline

Le résultat dans le premier cas est visible sur la figure \ref{prod_plus_rapide_sem_2prod_meme_vitesse_1conso}. 
On voit bien dans ce cas que le producteur 1 et 2 ne produisent pas en même temps mais à tour de rôle. Comme le consommateur est plus lent il consomme les entiers avec un retard de 2 indices. Par exemple, le producteur 2 écrit l'entier 2 à la case 2 et juste après le consommateur lit l'entier 0 à la case 0 (2 écritures ont été faite entre temps à cause de la rapidité des producteurs).\newline

Dans le cas où le consommateur est plus rapide (figure \ref{conso_plus_rapide_sem_2prod_meme_vitesse_1conso}), on remarque qu'il n'a pas de retard, il consomme les entiers directement après production ce qui est tout à fait cohérent.

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=0.4\textwidth]{screens/prod_plus_rapide_sem_2prod_meme_vitesse_1conso.png}
		\caption{2 producteurs plus rapide que le consommateur}
		\label{prod_plus_rapide_sem_2prod_meme_vitesse_1conso}
\end{figure}

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=0.4\textwidth]{screens/conso_plus_rapide_sem_2prod_meme_vitesse_1conso.png}
		\caption{Consommateur plus rapide que les 2 producteurs}
		\label{conso_plus_rapide_sem_2prod_meme_vitesse_1conso}
\end{figure}

\newpage

\subsection{1 Producteur/ 2 Consommateurs}

Nous avons également testé le cas opposé où il y a cette fois-ci un producteur et deux consommateurs. Le principe est exactement le même que précédemment sauf que le mutex s'applique aux deux consommateurs avant et après lecture d'un entier. De même que précédemment, les consommateurs partagent des variables globales. On suppose que les consommateurs ont la même vitesse.\newline

\begin{lstlisting}
#define TAILLE_TABLEAU 3

TACHE tacheStart();
TACHE tacheProd();
TACHE tacheConso1();
TACHE tacheConso2();
uint16_t prod, conso1, conso2;		// 2 conso et 1 prod
uint16_t fifo[TAILLE_TABLEAU];
uint16_t nb_places_libres = TAILLE_TABLEAU;
ushort sem1, sem2, semMutexConso;

// variables globales pour les producteurs
// l => indice de la file et j => valeur à cet indice
int l = 0, j = 0;

TACHE	tacheStart(void)
{
  puts("------> EXEC tache Start");

  prod = cree(tacheProd);
  conso1 = cree(tacheConso1);
  conso2 = cree(tacheConso2);

  active(conso1);
  active(conso2);
  active(prod);

  fin_tache();
}

TACHE	tacheProd(void)
{
  puts("------> EXEC tache Prod");

  uint16_t j=0,k,i=0;

  while(1)
  {
	  for (k=0; k<30000; k++);
	  //for (k=0; k<10000; k++);

	  if (nb_places_libres>=1)
	  {
		  _lock_();
		  printf("**PROD** -> Production : fifo[%d] = %d\n", i, j);
		  fifo[i]=j;
		  _unlock_();
		  j++;

		  nb_places_libres--;

		  i++;
		  if (i==TAILLE_TABLEAU)
			  i=0;
	  }
	  else
	  {
		  s_wait(sem1);		// dort()
	  }

	  if (nb_places_libres<TAILLE_TABLEAU)
	  {
		  s_signal(sem2);		// reveille(conso);
	  }

  }

  fin_tache();
}


TACHE	tacheConso1(void)
{
  uint16_t k;

  puts("------> EXEC tache Conso 1");

  s_wait(sem2);	// dort()

  while(1)
  {
	  //for (k=0; k<30000; k++);
	  for (k=0; k<10000; k++);


	  s_wait(semMutexConso); // P du mutex (entrée de la zone critique) 

	  if (nb_places_libres==TAILLE_TABLEAU)
	  {
		  s_wait(sem2);	// dort()
	  }
	  else
	  {
		  _lock_();
		 printf("**CONSO 1** -> Lecture de fifo[%d] = %d\n", l, fifo[l]);
		  _unlock_();

		  nb_places_libres++;

		  l++;
		  if (l==TAILLE_TABLEAU)
			  l=0;
	  }

	  s_signal(semMutexConso);// V du mutex (sortie de la zone critique)

	  if (nb_places_libres==1)
	  {
		  s_signal(sem1);	// reveille(prod);
	  }

  }

  fin_tache();
}

TACHE	tacheConso2(void)
{
  uint16_t k;

  puts("------> EXEC tache Conso 2");

  s_wait(sem2);	// dort()

  while(1)
  {
	  //for (k=0; k<30000; k++);
	  for (k=0; k<10000; k++);


	  s_wait(semMutexConso); // P du mutex (entrée de la zone critique) 

	  if (nb_places_libres==TAILLE_TABLEAU)
	  {
		  s_wait(sem2);	// dort()
	  }
	  else
	  {
		  _lock_();
		  printf("**CONSO 2** -> Lecture de fifo[%d] = %d\n",l, fifo[l]);
		  _unlock_();

		  nb_places_libres++;

		  l++;
		  if (l==TAILLE_TABLEAU)
			  l=0;
	  }

	  s_signal(semMutexConso);// V du mutex (sortie de la zone critique)


	  if (nb_places_libres==1)
	  {
		  s_signal(sem1);	// reveille(prod);
	  }

  }

  fin_tache();
}

int main()
{
  serial_init(115200);
  puts("Test noyau");
  puts("Noyau preemptif");
  puts("*******************DEBUT*********************\n\n\n\n\n");

  printf("TAILLE DU TABLEAU : %d\n", TAILLE_TABLEAU);

  s_init();
  sem1 = s_cree(0);		// prod
  sem2 = s_cree(0);		// conso
	
	// mutex entre les 2 consommateurs pour les empêcher de consommer en même temps
  semMutexConso = s_cree(1);		
	
  start(tacheStart);

  return(0);
}
\end{lstlisting}

Le résultat dans le cas où le producteur est plus rapide que les consommateurs est visible sur la figure \ref{prod_plus_rapide_sem_2conso_meme_vitesse_1prod}. Les consommateurs ont tendance à être en retard d'un ou deux indices.\newline
Pour le cas où les consommateurs sont plus rapides que le producteur (figure \ref{conso_plus_rapide_sem_2conso_meme_vitesse_1prod}), la consommation se fait dans l'ordre juste après les productions comme précédemment.

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=0.35\textwidth]{screens/prod_plus_rapide_sem_2conso_meme_vitesse_1prod.png}
		\caption{Producteur plus rapide que les 2 consommateurs}
		\label{prod_plus_rapide_sem_2conso_meme_vitesse_1prod}
\end{figure}

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=0.4\textwidth]{screens/conso_plus_rapide_sem_2conso_meme_vitesse_1prod.png}
		\caption{2 consommateurs plus rapide que le producteur}
		\label{conso_plus_rapide_sem_2conso_meme_vitesse_1prod}
\end{figure}

\newpage

\subsection{2 Producteurs/ 2 Consommateurs}

Finalement, nous avons implémenté le cas avec 2 producteurs et 2 consommateurs. Dans cette exemple, nous avons besoin des 2 mutex précédents, un pour empêcher les producteurs de produire en même temps et un autre pour empêcher les consommateurs de produire en même temps. Les producteurs partagent également des variables globales pour la file d'entiers et de même pour les consommateurs. Le principe reste exactement le même que précédemment.\newline

\begin{lstlisting}
#define TAILLE_TABLEAU 3

TACHE tacheStart();
TACHE tacheProd1();
TACHE tacheProd2();
TACHE tacheConso1();
TACHE tacheConso2();
uint16_t prod1, prod2, conso1, conso2;		// 2 conso et 2 prod
uint16_t fifo[TAILLE_TABLEAU];
uint16_t nb_places_libres = TAILLE_TABLEAU;
ushort sem1, sem2, semMutexConso, semMutexProd;

// variables globales pour les producteurs et consommateurs
int l = 0, j = 0, m = 0;


TACHE	tacheStart(void)
{
  puts("------> EXEC tache Start");

  prod1 = cree(tacheProd1);
  prod2 = cree(tacheProd2);
  conso1 = cree(tacheConso1);
  conso2 = cree(tacheConso2);

  active(conso1);
  active(conso2);
  active(prod1);
  active(prod2);

  fin_tache();
}

TACHE	tacheProd1(void)
{
  puts("------> EXEC tache Prod 1");

  uint16_t k;

  while(1)
  {
	  for (k=0; k<30000; k++);
	  //for (k=0; k<10000; k++);

	  s_wait(semMutexProd);// P du mutex (entrée de la zone critique)

	  if (nb_places_libres>=1)
	  {
		  _lock_();
		  printf("**PROD 1** -> Production : fifo[%d] = %d\n", l, j);
		  fifo[l]=j;
		  _unlock_();
		  j++;

		  nb_places_libres--;

		  l++;
		  if (l==TAILLE_TABLEAU)
			  l=0;
	  }
	  else
	  {
		  s_wait(sem1);		// dort()
	  }

	  s_signal(semMutexProd);// V du mutex (sortie de la zone critique)


	  if (nb_places_libres<TAILLE_TABLEAU)
	  {
		  s_signal(sem2);		// reveille(conso);
	  }

  }

  fin_tache();
}

TACHE	tacheProd2(void)
{
  puts("------> EXEC tache Prod 2");

  uint16_t k;

  while(1)
  {
	  for (k=0; k<30000; k++);
	  //for (k=0; k<10000; k++);

	  s_wait(semMutexProd);// P du mutex (entrée de la zone critique)

	  if (nb_places_libres>=1)
	  {
		  _lock_();
		  printf("**PROD 2** -> Production : fifo[%d] = %d\n", l, j);
		  fifo[l]=j;
		  _unlock_();
		  j++;

		  nb_places_libres--;

		  l++;
		  if (l==TAILLE_TABLEAU)
			  l=0;

	  }
	  else
	  {
		  s_wait(sem1);		// dort()
	  }

	  s_signal(semMutexProd);// V du mutex (sortie de la zone critique)

	  if (nb_places_libres<TAILLE_TABLEAU)
	  {
		  s_signal(sem2);		// reveille(conso);
	  }

  }

  fin_tache();
}


TACHE	tacheConso1(void)
{
  uint16_t k;

  puts("------> EXEC tache Conso 1");

  s_wait(sem2);	// dort()

  while(1)
  {
	  //for (k=0; k<30000; k++);
	  for (k=0; k<10000; k++);


	  s_wait(semMutexConso); // P du mutex (entrée de la zone critique)

	  if (nb_places_libres==TAILLE_TABLEAU)
	  {
		  s_wait(sem2);	// dort()
	  }
	  else
	  {
		  _lock_();
		 printf("**CONSO 1** -> Lecture de fifo[%d] = %d\n", m, fifo[m]);
		  _unlock_();

		  nb_places_libres++;

		  m++;
		  if (m==TAILLE_TABLEAU)
			  m=0;
	  }

	  s_signal(semMutexConso);// V du mutex (sortie de la zone critique)

	  if (nb_places_libres==1)
	  {
		  s_signal(sem1);	// reveille(prod);
	  }

  }

  fin_tache();
}

TACHE	tacheConso2(void)
{
  uint16_t k;

  puts("------> EXEC tache Conso 2");

  s_wait(sem2);	// dort()

  while(1)
  {
	  //for (k=0; k<30000; k++);
	  for (k=0; k<10000; k++);

	  s_wait(semMutexConso); // P du mutex (entrée de la zone critique)

	  if (nb_places_libres==TAILLE_TABLEAU)
	  {
		  s_wait(sem2);	// dort()
	  }
	  else
	  {
		  _lock_();
		  printf("**CONSO 2** -> Lecture de fifo[%d] = %d\n",m, fifo[m]);
		  _unlock_();

		  nb_places_libres++;

		  m++;
		  if (m==TAILLE_TABLEAU)
			  m=0;
	  }

	  s_signal(semMutexConso);// V du mutex (sortie de la zone critique)


	  if (nb_places_libres==1)
	  {
		  s_signal(sem1);	// reveille(prod);
	  }

  }

  fin_tache();
}

int main()
{
  serial_init(115200);
  puts("Test noyau");
  puts("Noyau preemptif");
  puts("*******************DEBUT*********************\n\n\n\n\n");

  printf("TAILLE DU TABLEAU : %d\n", TAILLE_TABLEAU);

  s_init();
  sem1 = s_cree(0);		// prod
  sem2 = s_cree(0);		// conso
  
  // mutex entre les 2 consommateurs pour les empêcher de consommer en même temps
  semMutexConso = s_cree(1);
  
  // mutex entre les 2 producteurs pour les empêcher de produire en même temps
  semMutexProd = s_cree(1);		

  start(tacheStart);

  return(0);
}
\end{lstlisting}

Pour cette exemple, nous avons testé trois configurations différentes :\newline 

1) Les producteurs et consommateurs ont tous la même vitesse (figure \ref{prod_conso_meme_vitesse_sem_2prod_meme_vitesse_2conso_meme_vitesse_TRAFIK}).

2) Les producteurs ont la même vitesse mais sont plus rapides que les consommateurs qui ont la même vitesse également (figure \ref{prod_plus_rapide_sem_2prod_meme_vitesse_2conso_meme_vitesse_TRAFIK}).

3) Les consommateurs ont la même vitesse mais sont plus rapides que les producteurs qui ont la même vitesse également (figure \ref{conso_plus_rapide_sem_2prod_meme_vitesse_2conso_meme_vitesse}).



\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=0.35\textwidth]{screens/prod_conso_meme_vitesse_sem_2prod_meme_vitesse_2conso_meme_vitesse_TRAFIK.png}
		\caption{2 producteurs et 2 consommateurs à la même vitesse}
		\label{prod_conso_meme_vitesse_sem_2prod_meme_vitesse_2conso_meme_vitesse_TRAFIK}
\end{figure}

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=0.4\textwidth]{screens/prod_plus_rapide_sem_2prod_meme_vitesse_2conso_meme_vitesse_TRAFIK.png}
		\caption{2 producteurs plus rapides que les 2 consommateurs}
		\label{prod_plus_rapide_sem_2prod_meme_vitesse_2conso_meme_vitesse_TRAFIK}
\end{figure}

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=0.4\textwidth]{screens/conso_plus_rapide_sem_2prod_meme_vitesse_2conso_meme_vitesse.png}
		\caption{2 consommateurs plus rapides que les 2 producteurs}
		\label{conso_plus_rapide_sem_2prod_meme_vitesse_2conso_meme_vitesse}
\end{figure}

\newpage

\end{document}

