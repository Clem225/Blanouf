\documentclass[a4paper,12pt]{report}
% Alternative Options:
%	Paper Size: a4paper / a5paper / b5paper / letterpaper / legalpaper / executivepaper
% Duplex: oneside / twoside
% Base Font Size: 10pt / 11pt / 12pt

\usepackage[export]{adjustbox}

\usepackage{geometry}
%% Language %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage[USenglish]{babel} %francais, polish, spanish, ...
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

\usepackage{verbatim}
\usepackage{lmodern} %Type1-font for non-english texts and characters


%% Packages for Graphics & Figures %%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx} %%For loading graphic files
%\usepackage{subfig} %%Subfigures inside a figure
%\usepackage{pst-all} %%PSTricks - not useable with pdfLaTeX

%% Please note:
%% Images can be included using \includegraphics{Dateiname}
%% resp. using the dialog in the Insert menu.
%% 
%% The mode "LaTeX => PDF" allows the following formats:
%%   .jpg  .png  .pdf  .mps
%% 
%% The modes "LaTeX => DVI", "LaTeX => PS" und "LaTeX => PS => PDF"
%% allow the following formats:
%%   .eps  .ps  .bmp  .pict  .pntg


%% Math Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}


%% Line Spacing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{setspace}
%\singlespacing        %% 1-spacing (default)
%\onehalfspacing       %% 1,5-spacing
%\doublespacing        %% 2-spacing
\usepackage{listings}
\lstset{language=C} 
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Octave,                 % the language of the code
  otherkeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}







%% NOTE POUR CLEMENT : UTILISE LE HEADER CI-DESSUS, IL EST MEILLEUR

%%AJOUTS DE CLEMENT DANS LE HEADER :
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Clément BLANQUET et Rafik CHENNOUF}
\rhead{Page \thepage}
\cfoot{\footnotesize{MI11 - Rapport des TPs linux embarqué}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\usepackage{titlesec}
\makeatletter
\titleformat{\chapter}[frame]
  {\normalfont}{\filright\enspace \@chapapp~\thechapter\enspace}
  {15pt}{\LARGE\bfseries\filcenter}
\titlespacing*{\chapter}
  {0pt}{0pt}{20pt}
\makeatother

\renewcommand{\thesection}{}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\makeatletter
\def\@seccntformat#1{\csname #1ignore\expandafter\endcsname\csname the#1\endcsname\quad}
\let\sectionignore\@gobbletwo
\let\latex@numberline\numberline
\def\numberline#1{\if\relax#1\relax\else\latex@numberline{#1}\fi}
\makeatother





\author{Clément BLANQUET et Rafik CHENNOUF}
\title{MI11 - Rapport TP 1 - Linux embarqué}

\begin{document}

\begin{titlepage}

	\centering
	\includegraphics[width=0.15\textwidth]{sigle_UTC.jpg}\par\vspace{1cm}
	{\scshape\LARGE Université de Technologie de Compiègne \par\vspace{1cm}}	
	{\scshape\Large MI11\par}
	\vspace{1.5cm}
	{\huge\bfseries Rapport des TPs linux embarqué\par}
	\vspace{2cm}
	{\Large\itshape Clément BLANQUET et Rafik CHENNOUF\par}
	\vspace{2cm}
	\vfill
% Bottom of the page
	{\large Juin 2017}
\end{titlepage}


\renewcommand{\contentsname}{Sommaire} % Changer le nom de la table des matieres
\tableofcontents
% Les différentes tables
\listoffigures        % Liste des figures




\chapter{Rapport TP 1 - Linux embarqué}

\section{Exercice 1 : Prise en main de la carte DevKit8600}
\subsection{Question 1.1}
La DevKit8600 est basée sur les processeurs AM3359 de Texas Instrument. Elle possède un ARM Cortex-A8 cadencé à 720 MHz avec un boot ROM On-Chip de 176KB. Elle possède un certain nombre d'interfaces comme un port LAN, une entrée/sortie audio, des USB, une interface JTAG... etc.

\subsection{Question 1.2} 
A FAIRE

\subsection{Question 1.3}
Nous avons utilisé une liaison série pour nous connecter avec l'application cutecom.

Voici les paramètres que l'on a utilisés :
\begin{enumerate}
\item Bits per second : 115200
\item Data bits : 8
\item Parity : None
\item Stop bits : 1
\item Flow Control : None
\end{enumerate}

\subsection{Question 1.4}
On constate qu'il y a une erreur au démarrage.

\begin{lstlisting}
TFTP error: 'File not found' (1)

ERROR: can't get kernel image!
\end{lstlisting}

La cible ne peut donc pas démarrer. Le fichier manquant est l'image du kernel, appelé \textbf{uImage}.
Il faudrait la placer dans le dossier /tftpboot sur notre PC, puisque la cible nous indique au démarrage qu'elle va cherche l'image à cet endroit.

\subsection{Question 1.5}
Même si l'image était présente, la cible ne pourrait pas démarrer car il manque un rootfs (système de fichier racine).

\section{Exercice 2}
\subsection{Question 2.1}
Le dossier \textit{/home/mi11/poky/build/conf} contient les fichiers de configurations de poky qui permettent donc de configurer l'image selon nos besoins :
\begin{itemize}
\item bblayers.conf
\item local.conf
\item sanity\_info
\item templateconf.cfg
\end{itemize}

Le dossier \textit{/home/mi11/devkit8600/meta-devkit8600} contient les fichiers spécifiques à notre cible qui vont permettre de construire une image qui lui est adaptée.

\subsection{Question 2.2}
Nous avons ajouté une ligne dans le fichier bblayers.conf :

\begin{lstlisting}
BBLAYERS ?= " \
  /home/mi11/poky-dizzy-12.0.3/meta \
  /home/mi11/poky-dizzy-12.0.3/meta-yocto \
  /home/mi11/poky-dizzy-12.0.3/meta-yocto-bsp \
  /home/mi11/devkit8600/meta-devkit8600 \  // CELLE LA
  "
\end{lstlisting}

De plus, à la ligne 36 du fichier local.conf, nous avons inscrit :

\begin{lstlisting}
MACHINE ??= "devkit8600"
\end{lstlisting}

Le nom "devkit8600" est en fait le nom du fichier de configuration du même nom situé ici : 
\textit{/home/mi11/devkit8600/meta-devkit8600/conf/machine}, ce qui fait donc le lien entre la génération de l'image et les paramètres de la cible.

\subsection{Question 2.3}
Voici ce qu'on obtient dans le dossier \textit{/home/mi11/poky/build/tmp/deploy/images} après la compilation : \smallbreak

\begin{figure}
\includegraphics[width=1\textwidth]{23dossierimage.PNG}
\caption{Dossier image} \bigbreak
\end{figure}


On obtient notre image kernel \textit{uImage} qui est en fait un lien symbolique vers le fichier \textit{uImage--3.1.0-r0-devkit8600-20170410160636.bin}.

On voit également le système de fichier nommé \textit{rootfs} qui est compressé dans une archive bzip2.

Si on compare la taille des fichiers qui viennent d'être générés avec ceux de notre VM sous Linux Mint :

\begin{itemize}
\item CIBLE :
\begin{itemize}
\item Taille image : 3,2 MB
\item Taille rootfs : 1,8 MB
\end{itemize}
\item HOTE :
\begin{itemize}
\item Taille image : 6,6 MB (on le voit dans /boot)
\item Taille système de fichiers : environ 7 GB
\end{itemize}
\end{itemize}

On constate une bonne différence entre les deux images car l'image de la cible n'est faite que pour cette cible là, elle gère moins de choses et propose moins de fonctionnalités que celle de notre VM. Pour le système de fichiers, on constate une énorme différence car beaucoup plus de programmes sont installés sur notre VM par rapport à la cible sur laquelle rien ou presque n'est installé.
La cible dispose en fait de la configuration minimale.

\section{Exercice 3}
\subsection{Question 3.1}
Comme nous l'avions indiqué dans le premier exercice, nous avons copié uImage dans le dossier \textit{/tftpboot}, comme c'est indiqué dans le fichier de configuration /etc/xinetd.d/tftp. 
Le rootfs, lui, est copié dans le dossier \textit{/tftpboot/rootfs}

\subsection{Question 3.2}
Messages de sortie du terminal entre l'allumage de la cible et le prompt de login : voir annexe \ref{message_sortie}.

A FINIR

\subsection{Question 3.3}
L'IP de la cible est 192.168.1.6. On peut voir cette adresse sur les messages de sortie du boot : "\textit{IP-Config: Got DHCP answer from 192.168.1.1, my address is 192.168.1.6 (sortie du boot)"}

\subsection{Question 3.4}
\textit{proc/devices} contient les périphériques (dans la première section) ainsi que les stockages (dans la deuxième section).
\begin{figure}[!]
\centering
\includegraphics[width=0.42\textwidth]{341.jpg}
\caption{Mise en évidence du port série dans /proc/devices}
\end{figure}

\begin{figure}[!]
\centering
\includegraphics[width=0.3\textwidth]{342.jpg}
\caption{Mise en évidence du port série dans /dev}
\end{figure}

Le numéro en début de ligne dans le fichier /proc/devices correspond au numéro mineur, qui indique si les périphériques sont gérés par le même driver.

\newpage

\subsection{Question 3.5}

A FAIRE


\section{Exercice 4 : Ajout de paquets}
\subsection{Question 4.1}

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{41dossier_deploy_ipk.png}
		\caption{Dossier \textit{ipk}}
\end{figure}

Le dossier \textit{/home/mi11/poky/build/tmp/deploy/ipk} est organisé par architectures (x86/x64, devkit8600, armv7a, etc.).

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{41ou_se_trouve_le_noyau.png}
		\caption{Dossier \textit{ipk/devkit800}}
\end{figure}

Les sous-dossiers contiennent des paquets d'extension \textit{.ipk}. Le noyau se trouve dans le sous-dossier \textit{devkit8600} comme nous pouvons le voir sur la copie d'écran ci-dessus. Quant au paquet \textit{libxml2}, il se trouve dans le sous-dossier \textit{armv7a-vfp-neon}.

\newpage

\subsection{Question 4.2}

Les différents paquets relatifs à \textit{libxml2} sont visibles sur la copie d'écran suivante.

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{42.png}
		\caption{Dossier \textit{ipk/armv7a-vfp-neon}}
\end{figure}

Nous avons ensuite copié le fichier 
\begin{verbatim}
libxml2_2.9.1-r0_armv7a-vfp-neon.ipk 
\end{verbatim}
dans le système de fichiers de la cible et nous avons installé le paquet avec la commande suivante : 
\begin{verbatim}
opkg install libxml2_2.9.1-r0_armv7a-vfp-neon.ipk
\end{verbatim}


\subsection{Question 4.3}

La première méthode pour copier le fichier dans le système de fichiers de la cible consiste à utiliser directement la commande \textit{cp} comme suit : 
\begin{verbatim}
sudo cp libxml2_2.9.1-r0_armv7a-vfp-neon.ipk /tftpboot/rootfs/home/root/
\end{verbatim}

La deuxième méthode consiste à copier le fichier à distance via la commande \textit{scp} qui se base sur \textit{ssh} comme suit : 
\begin{verbatim}
scp libxml2_2.9.1-r0_armv7a-vfp-neon.ipk root@192.168.1.6:/home/root/
\end{verbatim}

\newpage

\subsection{Question 4.4}

Les fichiers de \textit{libxml2} installés par le gestionnaire de paquets se trouvent dans le dossier \textit{/usr/lib} de notre cible.

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{44.png}
		\caption{Dossier \textit{/usr/lib}}
\end{figure}

Ce dossier contient des fichiers \textit{shared object} (.so) qui sont des librairies/bibliothèques partagées dynamiques.
Les .so sont des bibliothèques qui se chargent en mémoire au moment de l'exécution d'un programme qui les utilisent. Si plusieurs programmes les utilisant sont lancés en même temps, une seule instance de la bibliothèque dynamique réside en mémoire.

\section{Exercice 5 : Compilation manuelle du noyau}
\subsection{Question 5.1}

La page 72 de la documentation nous dit qu'il est possible d'allumer et d'éteindre les LEDs via les commandes suivantes :
\begin{verbatim}
root@DevKit8600:~# echo 1 > /sys/class/leds/user_led/brightness
root@DevKit8600:~# echo 0 > /sys/class/leds/user_led/brightness
\end{verbatim}

Comme le dossier 
\begin{verbatim} 
user_led 
\end{verbatim} 
n'existe pas ce n'est pas opérationnel.

\subsection{Question 5.2}

Nous avons ensuite compiler manuellement le noyau via la chaîne de compilation croisée en exécutant le script suivant :
\begin{verbatim} 
source /opt/poky/1.7.3/environment-setup-armv7a-vfp-neon-poky-linux-gnueabi
unset LDFLAGS
\end{verbatim} 

Le fichier ci-dessus sert à mettre en place l'environnement de compilation de manière à avoir les bons préfixes pour une compilation croisée.
Le préfixe la chaîne de compilation croisée est \textit{arm-poky-linux-gnueabi-}.

\subsection{Question 5.3}

Pour obtenir la liste des configurations par défaut du noyau pour une architecture ARM, il faut utiliser la commande \textit{make ARCH=arm help}.
Les configurations par défaut possibles pour la carte \textit{devkit8600} sont visibles sur la copie d'écran ci-dessous :

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{53.png}
		\caption{Configurations par défaut de \textit{devkit8600}}
\end{figure}

Nous avons retenu uniquement la première configuration et nous l'avons mise en place via la commande suivante : 
\begin{verbatim} 
make devkit8600_defconfig
\end{verbatim} 

\subsection{Question 5.4}

Ensuite, nous avons lancé la personnalisation du noyau via la commande suivante : \textit{make ARCH=arm menuconfig}.
Le but étant d'ajouter un driver pour les LEDs connectées par GPIO.
Pour cela, nous avons activé l'option \textit{LED Support for GPIO connected LEDs} comme on peut le voir sur la copie d'écran suivante.

\newpage

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{54.png}
		\caption{Activation du driver pour les LEDs}
\end{figure}

Ce driver peut être activé via deux modes, \textit{modularizes features} ou \textit{built-in}. Le premier mode est utilisé si l'on souhaite ajouter un driver en tant que module qui sera chargé en mémoire uniquement en cas de besoin et déchargé lorsque le kernel n'en a pas plus besoin. Ceci est utile lorsque l'on souhaite avoir un kernel pas très lourd.
Quant au deuxième mode, le driver sera directement intégré au kernel et il sera disponible tout le temps. Le kernel sera donc plus gros, plus lent et utilisera plus de mémoire.
Dans notre cas, nous avons utilisé le mode \textit{built-in}.\newline

Nous avons ensuite compiler notre noyau avec la commande suivante : \textit{make ARCH=arm uImage -j2}.

\newpage

\subsection{Question 5.5}

Le résultat de la compilation se trouve dans \textit{arch/arm/boot/uImage}.

Nous avons ensuite copier le fichier uImage dans /tftpboot pour qu'il soit utilisé par la cible puis nous l'avons démarré.

\subsection{Question 5.6}

Pour vérifier dans les logs de démarrage que le noyau utilisé est bien celui qui vient d'être compilé, il suffit de lire la date de compilation :

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{56.png}
		\caption{Logs de démarrage}
\end{figure}

Nous pouvons lire sur la copie d'écran précédente la ligne suivante : 
\begin{verbatim}
Linux version 3.1.0 (mi11@mi11-VirtualBox) (gcc version 4.9.1 (GCC) ) #1 Fri Apr 14 17:25:26 CEST 2017
\end{verbatim}

La date de compilation du noyau correspond bien à celui qui vient d'être compilé.

\newpage

\subsection{Question 5.7}

Pour vérifier dans les logs de démarrage que la fonctionnalité ajoutée est bien présente, on peut utiliser la commande \textit{dmesg} pour afficher les messages du kernel :

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{57.png}
		\caption{Logs du kernel}
\end{figure}

Le driver a bien été ajouté et le dossier 
\begin{verbatim}
used_led 
\end{verbatim}
a été crée.


\chapter{Rapport TP 2 - Linux embarqué}

\section{Exercice 1 :  Hello World}

\subsection{Question 1.1}

Après avoir compilé notre programme \textit{Hello World} avec \textbf{gcc} nous avons exécute la commande file pour obtenir des informations sur l'exécutable. Nous nous sommes rendu compte que cet exécutable a été compilé pour une architecture classique x86/64 et non ARM. C'est pour cela que le programme ne peut pas s'exécuter sur la cible. 

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{screenstp6/11.png}
		\caption{Commande \textit{file}}
\end{figure}

\subsection{Question 1.2}

Avant de pouvoir cross-compiler notre programme il faut activer l'environnement de cross-compilation via la commande \textit{source} sur le fichier \\
\textbf{/opt/poky/1.7.3/environment-setup-armv7a-vfp-neon-poky-linux-gnueabi}.

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{screenstp6/12.png}
		\caption{Commande \textit{source}}
\end{figure}


\subsection{Question 1.3}

En utilisant de nouveau la commande \textit{file} après la cross-compilation, nous constatons que le nouveau exécutable a bien été compilé pour une architecture ARM.

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{screenstp6/13.png}
		\caption{Commande \textit{file}}
\end{figure}

\subsection{Question 1.4}

Voici le programme \textit{Hello World} :

\begin{lstlisting}
#include <stdio.h>

int main()
{
		printf("Hello World !");
		return 0;
}
\end{lstlisting}

Ainsi que le résultat :

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{screenstp6/14.png}
		\caption{Résultat \textit{Hello World}}
\end{figure}

\section{Exercice 2 :  Clignotement des LEDs}

\subsection{Question 2.1}

Pour accéder aux LEDs il suffit de manipuler les fichiers 
\begin{verbatim}
/sys/class/leds/user_led/brightness
\end{verbatim}
pour la LED utilisateur et 
\begin{verbatim}
/sys/class/leds/sys_led/brightness 
\end{verbatim}
pour la LED système.

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{screenstp6/21.png}
		\caption{Fichiers des LEDs}
\end{figure}

\subsection{Question 2.2}

L'allumage d'une LED se fait en écrivant le caractère '1' dans le fichier correspondant et l'éteignage se fait en écrivant le caractère '0' comme on peut le voir sur la copie d'écran suivante.

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{screenstp6/22.png}
		\caption{Manipulation des LEDs}
\end{figure}

\subsection{Question 2.3}

Le programme suivant allume en alternance la LED utilisateur et la LED système chaque seconde :

\begin{lstlisting}
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

int main()
{
	int sys_led, user_led;

	sys_led = open("/sys/class/leds/sys_led/brightness", O_RDWR);	
	// ouverture des fichiers
	user_led = open("/sys/class/leds/user_led/brightness", O_RDWR); 

	if(sys_led == -1 || user_led == -1)
	{
		perror("Erreur d'ouverture de l'un des fichiers");
		return 0;
	}

	while(1)
	{
		if(write(user_led, "0", 1) == -1)	// éteingage de la LED user
			perror("Erreur d'ecriture");

		if(write(sys_led, "1", 1) == -1)    // allumage de la LED système
			perror("Erreur d'ecriture");

		sleep(1);							// attente d'une seconde

		if(write(sys_led, "0", 1) == -1)	// éteingage de la LED système
			perror("Erreur d'ecriture");

		if(write(user_led, "1", 1) == -1)   // allumage de la LED user
			perror("Erreur d'ecriture");

		sleep(1);							// attente d'une seconde
	}

	close(sys_led);		// fermeture
	close(user_led);	// des fichiers

	return 0;
}
\end{lstlisting}


\newpage

\section{Exercice 3 : Boutons poussoirs}
\subsection{Question 3.1}
La cible dispose de trois boutons utilisateur (HOME, BACK, MENU) et un bouton de reset. On y accède via le fichier "\textit{/dev/input/event1}" dans lequel toutes les informations quant aux pressions et relâchement de ces boutons seront écrites.

\subsection{Question 3.2}
Pour tester en ligne de commande, on peut utiliser "\textit{evtest /dev/input/event1}" (voir figure \ref{32})
\begin{figure}\centering
\includegraphics[width=0.5\textwidth]{screenstp6/32.PNG}
\caption{Résultat du evtest sur /dev/input/event1} \label{32}
\end{figure}

Les valeurs sont soit à 1 soit à 0 selon l'état du bouton : pressé ou relâché.

\subsection{Question 3.3}
La structure input\_event est déclarée dans le fichier suivant : 

\hspace{-0.8cm}"\textit{
/opt/poky/1.7.3/sysroots/armv7a-vfp-neon-poky-linux-gnueabi/usr/include/linux/input.h}" \medbreak
Au début de notre fichier C, on ajoute donc : "\#include <linux/input.h>".
Voici le programme que nous avons codé. Celui-ci lit les événements indiqués dans le fichier "/dev/input/event1", affiche ces événements dans le terminal et allume :

\begin{itemize}
\item La sys\_led en cas de pression sur le bouton MENU
\item La user\_led en cas de pression sur le bouton BACK
\item Les deux LEDs en cas de pression sur la touche HOME
\end{itemize}

\subsection{Question 3.4}

\begin{lstlisting}
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/input.h>
#include <sys/types.h>
#include <sys/stat.h>

int main()
{
	struct input_event event_buttons;
	int sys_led, user_led, buttons;

	buttons = open("/dev/input/event1", O_RDONLY); 

	if(buttons == -1)
	{
		perror("Erreur d'ouverture de l'un des fichiers");
		return 0;
	}

	sys_led = open("/sys/class/leds/sys_led/brightness", O_RDWR);
	user_led = open("/sys/class/leds/user_led/brightness", O_RDWR);

	if(sys_led == -1 || user_led == -1)
	{
		perror("Erreur d'ouverture de l'un des fichiers");
		return 0;
	}

	while(1)
	{
		
		read(buttons, &event_buttons, sizeof(event_buttons));

		int code = (int)event_buttons.code;
		int value = (int)event_buttons.value;

		switch(code)
		{
			case KEY_F1: // MENU
				if(value == 1)
				{
					printf("MENU PUSH\n");
					if(write(sys_led, "1", 1) == -1)
						perror("Erreur d'ecriture");
				}
				else
				{
					printf("MENU RELEASE\n");
					if(write(sys_led, "0", 1) == -1)
						perror("Erreur d'ecriture");
				}
			break;

			case KEY_ESC: // BACK
				if(value == 1)
				{
					printf("BACK PUSH\n");
					if(write(user_led, "1", 1) == -1)
						perror("Erreur d'ecriture");
				}
				else
				{
					printf("BACK RELEASE\n");
					if(write(user_led, "0", 1) == -1)
						perror("Erreur d'ecriture");
				}
			break;

			case KEY_HOME: // HOME
				if(value == 1)
				{
					printf("HOME PUSH\n");
					if(write(user_led, "1", 1) == -1)
						perror("Erreur d'ecriture");
					if(write(sys_led, "1", 1) == -1)
						perror("Erreur d'ecriture");
				}
				else
				{
					printf("HOME RELEASE\n");
					if(write(user_led, "0", 1) == -1)
						perror("Erreur d'ecriture");
					if(write(sys_led, "0", 1) == -1)
						perror("Erreur d'ecriture");
				}
			break;
		}
	}
	if(close(sys_led) == -1)
		perror("Erreur de fermeture de l'un des fichiers");
	if(close(user_led) == -1)
		perror("Erreur de fermeture de l'un des fichiers");
	if(close(buttons) == -1)
		perror("Erreur de fermeture de l'un des fichiers");

	return 0;
}
\end{lstlisting}


\section{Exercice 4 : Charge CPU}
\subsection{Question 4.1}
Voici notre programme : 
\begin{lstlisting}
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
 
#define TAILLE 10000

int main()
{
	int j = 0, tempstotal = 0;
	struct timeval debut, fin, res;
	gettimeofday(&debut, NULL);
	for(j = 0; j < TAILLE; j++)
	{
		usleep(1000);
	}
	gettimeofday(&fin, NULL);
	timersub(&fin, &debut, &res);
	int tempstotal = res.tv_sec* 1000000 + res.tv_usec;

	printf("Temps total : %d\n, tempstotal);

	return 0;
}
\end{lstlisting}

A COMPLETER

\subsection{Question 4.2}
Voici notre programme modifié :
\begin{lstlisting}
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
 
#define TAILLE 10000

int main()
{
	int j = 0, min, max, moy = 0, tempstotal = 0;
	int tab[TAILLE];
	struct timeval debut, fin, res;
		
	for(j = 0; j < TAILLE; j++)
	{
		gettimeofday(&debut, NULL);
		usleep(1000);
		gettimeofday(&fin, NULL);
		timersub(&fin, &debut, &res);
		tab[j] = res.tv_sec* 1000000 + res.tv_usec;
		moy += tab[j];
	}

	moy = moy / TAILLE - 1000;
	min = tab[0];
	max = tab[0];

	for(j = 1; j < TAILLE; j++)
	{
		if(min > tab[j])
			min = tab[j];

		if(max < tab[j])
			max = tab[j];
	}
	
	min-=1000;
	max-=1000;

	printf("Moyenne : %d\nMaximum : %d\nMinimum : %d\n", moy, max, min);

	return 0;
}
\end{lstlisting}

Voici les temps relevés :

\begin{itemize}
\item Sans stress :
\begin{itemize}
\item Moyenne : 85 ms
\item Maximum : 772 ms
\item Minimum : 13 ms
\end{itemize}
\item Avec stress :
\begin{itemize}
\item Moyenne : 766 ms
\item Maximum : 304397 ms
\item Minimum : 27 ms
\end{itemize}
\end{itemize}





\chapter{TP1 Xenomai}

\section{Exercice 1 : tâches}

\subsection{Question 1.1}
Un code "classique" ne s'exécute pas de façon temps réel. En effet, il n'apparaît pas dans le fichier /proc/xenomai/stats ce qui signifie qu'il n'est pas temps réel.\smallbreak
\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{screenstp7/11.PNG}
\caption{Statistiques Xenomai avec un programme non temps réel}
\end{figure}

\subsection{Question 1.2}
Voici le code qui permet de créer une tâche temps réel :
\begin{lstlisting}
#include <stdio.h>
#include <native/task.h>
#include <analogy/os_facilities.h>
#include <unistd.h>
#include <sys/mman.h>

#define TASK_PRIO 99
#define TASK_MODE 0
#define TASK_STKSZ 0

RT_TASK task_printf;

void task_hello()
{
	while(1)
	{
		sleep(rt_timer_ns2ticks(1000000000));
		printf("Hello World !\n");
	}
}

int main()
{
	mlockall(MCL_CURRENT|MCL_FUTURE);
	rt_print_auto_init(1);
	int err;
	
	err = rt_task_create(&task_printf, "hello world", TASK_STKSZ, TASK_PRIO, TASK_MODE);
	if(!err)
		rt_task_start(&task_printf, &task_hello, NULL);
		
	getchar();
	
	return 0;
}
\end{lstlisting}


Le chemin des fichiers à inclure est: 
\begin{lstlisting}
/opt/poky/1.7.3/sysroots/armv7a-vfp-neon-poky-linux-gnueabi/usr/include/xenomai
\end{lstlisting}
Le chemin des librairies est : 
\begin{lstlisting}
/opt/poky/1.7.3/sysroots/armv7a-vfp-neon-poky-linux-gnueabi/usr/lib
\end{lstlisting}

Cela nous donne la ligne de commande (après avoir fait un \textit{source}) :
\begin{lstlisting}
$CC -o main main.c -I/opt/poky/1.7.3/sysroots/armv7a-vfp-neon-poky-linux-gnueabi/usr/include/xenomai -L/opt/poky/1.7.3/sysroots/armv7a-vfp-neon-poky-linux-gnueabi/usr/lib -lxenomai -lnative
\end{lstlisting}

\subsection{Question 1.3}
Cette application n'est toujours pas temps réel. En effet, malgré la création d'une tâche temps réel, les fonctions \textit{sleep} et \textit{printf} qui s'y trouvent ne sont pas temps réel.

Le fichier de statistiques Xenomai donne :
\newpage
\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{screenstp7/13.PNG}
\caption{Statistiques Xenomai avec une tâche temps réel}
\end{figure}

\subsection{Question 1.4}
Voici le code après avoir remplacé la fonction sleep par son équivalent temps réel :
\begin{lstlisting}
void task_hello()
{
	while(1)
	{
		rt_task_sleep(rt_timer_ns2ticks(1000000000));
		printf("Hello World !\n");
	}
}
\end{lstlisting}

Le fichier de statistiques Xenomai donne :
\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{screenstp7/14.PNG}
\caption{Statistiques Xenomai avec une tâche temps réel et la fonction rt\_task\_sleep}
\end{figure}


\subsection{Question 1.5}
Voici le code après avoir remplacé les fonctions sleep et printf par leurs équivalents temps réel :
\begin{lstlisting}
void task_hello()
{
	while(1)
	{
		rt_task_sleep(rt_timer_ns2ticks(1000000000));
		rt_printf("Hello World !\n");
	}
}
\end{lstlisting}

Le fichier de statistiques Xenomai donne :
\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{screenstp7/15.PNG}
\caption{Statistiques Xenomai avec une tâche temps réel et les fonctions rt\_task\_sleep et rt\_printf}
\end{figure}

\textbf{Interprétation des statistiques Xenomai :} On constate que : 
\begin{itemize}
\item Lorsqu'on crée une tâche temps réel qui n'utilise aucune fonction temps réel (dans notre exemple, les fonctions \textit{sleep} et \textit{printf}, elle n'apparaît pas dans le fichier de statistiques. Elle n'est en fait absolument pas temps réel.
\item Lorsque, dans cette même tâche, on rend la fonction \textit{sleep} temps réel (en la remplaçant par \textit{rt\_task\_sleep}), elle apparaît dans le fichier de statistiques. On constate que son nombre de changements de contexte (9) est très inférieur  au nombre de changements de contexte du ROOT (282), ce qui signifie que ... A COMPLETER
\item Lorsque les fonctions \textit{sleep} et \textit{printf} ont été remplacées par leurs équivalents temps réel (\textit{rt\_task\_sleep} et \textit{rt\_printf}), le nombre changements de contextes de la tâche est égal à celui de ROOT (46), ce qui montre alors que la tâche est "entièrement" temps réel.
\end{itemize}

\section{Exercice 2 : Synchronisation}
\subsection{Question 2.1}
Voici le code du programme lançant deux tâches Xenomai qui afficheront chacune une partie du message "Hello World !" :
\begin{lstlisting}
#include <stdio.h>
#include <native/task.h>
#include <analogy/os_facilities.h>
#include <unistd.h>
#include <sys/mman.h>

#define TASK_PRIO 99
#define TASK_MODE 0
#define TASK_STKSZ 0

RT_TASK task_printf;
RT_TASK task_printf2;

void task_hello()
{
	rt_printf("Hello\n");
}

void task_world()
{
	rt_printf("World !\n");
	rt_task_sleep(rt_timer_ns2ticks(1000000000));
}


int main()
{
	mlockall(MCL_CURRENT|MCL_FUTURE);
	rt_print_auto_init(1);
	int err1, err2;
	
	err1 = rt_task_create(&task_printf, "hello", TASK_STKSZ, TASK_PRIO, TASK_MODE);
	err2 = rt_task_create(&task_printf2, "world", TASK_STKSZ, TASK_PRIO, TASK_MODE);
	if(!err1 && !err2)
	{
		rt_task_start(&task_printf, &task_hello, NULL);
		rt_task_join(&task_printf);	
		rt_task_start(&task_printf2, &task_world, NULL);
		rt_task_join(&task_printf2);	
	}
		
	getchar();
	
	return 0;
}
\end{lstlisting}


Le résultat est le suivant :
\begin{lstlisting}
root@devkit8600-xenomai:~# ./synchro
Hello
World !
c
root@devkit8600-xenomai:~# 
\end{lstlisting}


\subsection{Question 2.2}
Pour le moment, les priorités des tâches n'ont aucune influence. En effet, elles sont lancées dans l'ordre dans lequel elles se trouvent dans notre code : après le \textit{rt\_task\_start}, rien ne "bloque" l'exécution de la tâche; les tâches se lancent donc l'une après l'autre comme on l'a défini. Pour afficher les messages de le désordre, il faut donc inverser les deux tâches le code. On peut aussi utiliser des sémaphores, comme vu dans les questions suivantes.

\subsection{Question 2.3}
Il faut initialiser le sémaphore à 0 de manière à bloquer les tâches.

\subsection{Question 2.4}

Le paramètre \textit{mode} lors de la création du sémaphore nous sert à définir le mode d'ordonnancement à utiliser.
Par exemple, si on choisit le mode \textit{S\_FIFO} alors les tâches seront ordonnancés en suivant la méthode FIFO (First In First Out), c'est à dire que les tâches attendront dans leur ordre d'arrivée que le sémaphore se libère. Un second exemple de \textit{mode} utilisable est le mode \textit{S\_PRIO} qui permet d'ordonnancer les tâches par ordre de priorité, c'est à dire que les tâches avec la plus haute priorité auront accès au sémaphore avant les tâches de plus faible priorité.\newline


\subsection{Question 2.5}

\begin{lstlisting}
#include <stdio.h>
#include <native/task.h>
#include <analogy/os_facilities.h>
#include <unistd.h>
#include <sys/mman.h>
#include <native/sem.h>

#define TASK_PRIO_HELLO 98
#define TASK_PRIO_WORLD 99
//#define TASK_PRIO 99
#define TASK_MODE 0
#define TASK_STKSZ 0

RT_TASK task_printf;
RT_TASK task_printf2;
RT_SEM sem;


void task_hello()			// affichage de 'Hello'
{
	rt_sem_p (&sem, 0);	// décrémentation du sémaphore
	rt_printf("Hello\n");
}

void task_world()			// affichage de 'World'
{
	rt_sem_p (&sem, 0);	// décrémentation du sémaphore
	rt_printf("World !\n");
}


int main()
{
	mlockall(MCL_CURRENT|MCL_FUTURE);
	rt_print_auto_init(1);
	int err1, err2;
	
	// création du sémaphore en mode FIFO
	rt_sem_create (&sem, "sem", 0, S_FIFO);				
	
	// création des deux tâches
	err1 = rt_task_create(&task_printf, "hello", TASK_STKSZ, TASK_PRIO_HELLO, TASK_MODE);
	err2 = rt_task_create(&task_printf2, "world", TASK_STKSZ, TASK_PRIO_WORLD, TASK_MODE);
	
	
	if(!err1 && !err2)
	{
		// démarrage de la tâche qui affiche 'Hello'
		rt_task_start(&task_printf, &task_hello, NULL);  
		
		// attente de sa terminaison
		rt_task_join(&task_printf);					
								
	  // démarrage de la tâche qui affiche 'World'
		rt_task_start(&task_printf2, &task_world, NULL); 
		
		// attente de sa terminaison
		rt_task_join(&task_printf2);										
		
		getchar();
		
		rt_sem_v (&sem);	// incrémentation du sémaphore
		rt_sem_v (&sem);	// incrémentation du sémaphore
	}
		
	return 0;
}
\end{lstlisting}

Le programme précédent avec le mode \textit{S\_FIFO} pour le sémaphore nous donne le résultat suivant :

\begin{lstlisting}
root@devkit8600-xenomai:~# ./synchro

Hello
World !
\end{lstlisting}

Cependant, si nous utilisons le mode \textit{S\_PRIO} pour le sémaphore nous obtenons :

\begin{lstlisting}
root@devkit8600-xenomai:~# ./synchro

World !
Hello
\end{lstlisting}

Ceci est cohérent puisque nous avons défini les priorités comme suit : 

\begin{lstlisting}
#define TASK_PRIO_HELLO 98
#define TASK_PRIO_WORLD 99
\end{lstlisting}

La tâche qui s'occupe d'afficher le 'World !' est plus prioritaire que la tâche qui affiche le 'Hello'.


\subsection{Question 2.6}

\begin{lstlisting}
#include <stdio.h>
#include <native/task.h>
#include <analogy/os_facilities.h>
#include <unistd.h>
#include <sys/mman.h>
#include <native/sem.h>

#define TASK_PRIO_HELLO 98
#define TASK_PRIO_WORLD 97
#define TASK_PRIO_METRO 99
//#define TASK_PRIO 99
#define TASK_MODE 0
#define TASK_STKSZ 0

RT_TASK task_printf;
RT_TASK task_printf2;
RT_TASK task_metronome;
RT_SEM sem;

void task_hello()
{
	while(1)
	{
		rt_sem_p (&sem, 0);	// décrémentation du sémaphore
		rt_printf("Hello\n");
	}
}

void task_world()
{
	while(1)
	{
		rt_sem_p (&sem, 0); // décrémentation du sémaphore
		rt_printf("World !\n");
		rt_sem_v (&sem);    // incrémentation du sémaphore
	}
}

void task_metro()		// tâche métronome
{
	while(1)
	{
		rt_sem_v (&sem); // incrémentation du sémaphore
		rt_sem_v (&sem); // incrémentation du sémaphore
		
		rt_sem_p (&sem, 0); // décrémentation du sémaphore
		rt_task_sleep(rt_timer_ns2ticks(1000000000));	// attente 1 sec
	}
}


int main()
{
	mlockall(MCL_CURRENT|MCL_FUTURE);
	rt_print_auto_init(1);
	int err1, err2, err3;
	
	// création du sémaphore en mode PRIO
	rt_sem_create (&sem, "sem", 0, S_PRIO);
	
	err1 = rt_task_create(&task_printf, "hello", TASK_STKSZ, TASK_PRIO_HELLO, TASK_MODE);
	err2 = rt_task_create(&task_printf2, "world", TASK_STKSZ, TASK_PRIO_WORLD, TASK_MODE);
	
  // création de la tâche métronome
	err3= rt_task_create(&task_metronome, "metro", TASK_STKSZ, TASK_PRIO_METRO, TASK_MODE);
	
	if(!err1 && !err2 && !err3)
	{
		rt_task_start(&task_printf, &task_hello, NULL);
		rt_task_join(&task_printf);
		rt_task_start(&task_printf2, &task_world, NULL);
		rt_task_join(&task_printf2);
		
	  // démarrage de la tâche métronome
		rt_task_start(&task_metronome, &task_metro, NULL);
	  // attente de sa terminaison
		rt_task_join(&task_metronome);
		
		getchar();
		
	}
		
	return 0;
}
\end{lstlisting}

Le programme ci-dessus nous donne le résultat suivant à l'infini :

\begin{lstlisting}
root@devkit8600-xenomai:~# ./synchro

Hello
World !
Hello
World !
Hello
World !
\end{lstlisting}

La tâche métronome possède la plus haute priorité comme on peut le voir ci-dessous :

\begin{lstlisting}
#define TASK_PRIO_HELLO 98
#define TASK_PRIO_WORLD 97
#define TASK_PRIO_METRO 99
\end{lstlisting}

Initialement, les tâches 'Hello' et 'World' sont bloquées.
A chaque activation de la tâche métronome, le sémaphore est incrémenté de 2. A la première incrémentation, c'est la tâche 'Hello' qui prend la main puisque elle a une priorité supérieure à la tâche 'World'. La tâche 'Hello' décrémente le sémaphore et affiche 'Hello'.
Ensuite, la tâche métronome reprend son exécution puisque la tache 'World' est bloquée et elle incrémente une seconde fois le sémaphore. La tâche 'World' est donc débloquée, elle décrémente le sémaphore, affiche 'World !' puis incrémente le sémaphore pour débloquer la tâche métronome qui va reprendre son exécution en décrémentant le sémaphore et en faisant une attente d'une seconde avant de relancer le même processus. *** CLEEEEEEEEEEEEEEEEEEEEEEEEMENT : TU PEUX CONFIRMER CE QUE JE DIS J'AI UN DOUTE ***

\subsection{Question 2.7}

Le fichier de statistiques de Xenomai lors du lancement de notre programme est le suivant :

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{screenstp7/271.png}
		\caption{Fichier de statistiques de Xenomai}
\end{figure}

On retrouve bien nos 3 tâches 'hello', 'world' et 'metro'. On voit également que ces tâches ne subissent que très peu de changements de contexte (CSW) car ce sont des tâches temps-réel.\newline

Pour le fichier du scheduler de Xenomai nous avons : 

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{screenstp7/272.png}
		\caption{Fichier du scheduler de Xenomai}
\end{figure}

\newpage
Nous retrouvons bien les priorités de nos tâches que nous avons défini dans notre code. On voit également que nos trois tâches sont temps-réel via la colonne \textit{CLASS} (rt). On voit également que la tâche 'ROOT' qui correspond à Linux est en mode 'idle', c'est à dire qu'elle a priorité la plus faible (-1). Dans la colonne \textit{STAT}, on remarque que la tâche 'metro' est marquée de la lettre 'D' qui signifie 'Delayed', c'est à dire que la tâche est retardée sans aucune autre condition d'attente (wait d'une seconde). Les tâches 'hello' et 'metro' sont marquées de la lettre 'W' qui signifie que ces tâches sont en attente d'une ressource (sémaphore) et la tâche 'ROOT' est marquée de la lettre 'R' qui signifie 'Runnable', c'est à dire que la tâche est exécutable. 

\section{Exercice 3 : Latence}

\subsection{Question 3.1}

\begin{lstlisting}
#include <stdio.h>
#include <native/task.h>
#include <analogy/os_facilities.h>
#include <unistd.h>
#include <sys/mman.h>
#include <native/sem.h>
#include <nucleus/timer.h>

#define TASK_PRIO 99
#define TASK_MODE 0
#define TASK_STKSZ 0
#define TAILLE 10000

RT_TASK task_latence;

void task_wait()
{
	int i;
	
	// boucle de 1 à 10000
	for(i = 0; i < TAILLE; i++)
	{
		// attente de 1ms
		rt_task_sleep(rt_timer_ns2ticks(1000000));
	}
}

int main()
{
	mlockall(MCL_CURRENT|MCL_FUTURE);
	rt_print_auto_init(1);
	int err1;
	
	err1 = rt_task_create(&task_latence, "wait", TASK_STKSZ, TASK_PRIO, TASK_MODE);

	if(!err1)
	{
		rt_task_start(&task_latence, &task_wait, NULL);
		rt_task_join(&task_latence);
		
		getchar();
	}
		
	
	return 0;
}
\end{lstlisting}


\subsection{Question 3.2}

\begin{lstlisting}
#include <stdio.h>
#include <native/task.h>
#include <analogy/os_facilities.h>
#include <unistd.h>
#include <sys/mman.h>
#include <native/sem.h>
#include <nucleus/timer.h>


#define TASK_PRIO 99
#define TASK_MODE 0
#define TASK_STKSZ 0
#define TAILLE 10000

RT_TASK task_latence;

void task_wait()
{
	int i;
	RTIME moy = 0, min, max;
	RTIME begin, end;
	
	min = 9999999999999;
	max = 0;
	
	
	for(i = 0; i < TAILLE; i++)
	{
		begin = rt_timer_read();	// lecture du temps
		rt_task_sleep(rt_timer_ns2ticks(1000000));
		end = rt_timer_read();		// lecture du temps
		
		if(min > end - begin)			// calcul du min
			min = end - begin;

		if(max < end - begin)			// calcul du max
		{
			max = end - begin;
		}
		
		moy += end - begin;	 // calcul de la moyenne
	}
	
	moy = moy / TAILLE;
	
	rt_printf("Moyenne :%llu \nMaximum : %llu \nMinimum : %llu\n", moy, max, min);

}


int main()
{
	mlockall(MCL_CURRENT|MCL_FUTURE);
	rt_print_auto_init(1);
	int err1;
	
	err1 = rt_task_create(&task_latence, "wait", TASK_STKSZ, TASK_PRIO, TASK_MODE);

	if(!err1)
	{
		rt_task_start(&task_latence, &task_wait, NULL);
		rt_task_join(&task_latence);
		
		getchar();
	}
		
	
	return 0;
}
\end{lstlisting}

\newpage
Le programme précédent nous donne le résultat suivant : 

\begin{figure}[h]
	\centering
		\includegraphics[width=0.6\textwidth]{screenstp7/32.png}
		\caption{Résultat du programme \textit{Latence} sans stress}
\end{figure}

\subsection{Question 3.3}

Ici, on charge le CPU via la commande \textit{stress} avant de lancer notre programme :

\begin{figure}[h]
	\centering
		\includegraphics[width=0.6\textwidth]{screenstp7/33.png}
		\caption{Résultat du programme \textit{Latence} avec stress}
\end{figure}

On remarque que les résultats avec charge CPU et sans charge CPU sont pratiquement les même ce qui veut dire que la charge n'a aucune influence sur les tâches exécutées. Ceci est logique puisque le programme est temps-réel donc une charge CPU ne ralentira que les programmes non temps-réel qui sont toujours reliés à Linux (ROOT) comme on a pu le constater dans le tp précédent. Ici, les tâches temps-réel ont la plus grande priorité sur le CPU.

\chapter{TP2 Xenomai}

\section{Exercice : Pathfinder}

\subsection{Question 1}

La fonction \textit{create\_and\_start\_rt\_task}...

La fonction \textit{rt\_task}...

La structure \textit{task\_descriptor} permet d'obtenir des informations de la tâche en cours, c'est à dire :
\begin{itemize}
	\item la tâche elle même (de type RT\_TASK)
	\item le pointeur vers la fonction associée
	\item la période de la tâche
	\item la durée d'exécution la tâche
	\item la priorité de la tâche
	\item si la tâche utilise une ressource ou non
\end{itemize} 


\subsection{Question 2}
La fonction \textit{rt\_task\_name} sert à obtenir le nom de la tâche en cours grâce à la structure RT\_TASK\_INFO et son champ \textit{name}. Cette structure a d'autres champs :
\begin{itemize}
\item bprio : priorité de base (ne change pas au cours du temps)
\item cprio : priorité actuelle (peut changer au cours du temps)
\item status : statut de la tâche
\item relpoint : temps restant avant la prochaine exécution
\item exectime : temps d'exécution de la tâche depuis son lancement
\item modeswitches : nombre de changements de mode primaire / secondaire
\item ctxswitches : nombre de changements de contextes
\item pagefaults : nombre de défauts de page
\end{itemize}

\newpage
\subsection{Question 3}

Voici notre fonction \textit{busy\_wait} :

\begin{lstlisting}
void busy_wait(RTIME time) 
{ 
  	static RT_TASK_INFO info;			// info sur la tâche
  	rt_task_inquire(NULL,&info);		// initialisation des infos dont exectime
  	RTIME begin = info.exectime;		// recuperation du temps d'execution initial (> 0)
  
  
    while(info.exectime - begin < time)
  		  rt_task_inquire(NULL,&info);	// initialisation des infos dont exectime
}
\end{lstlisting}

On commence par acquérir les informations relatives à la tâche grâce à une structure RT\_TASK\_INFO et à la fonction rt\_task\_inquire. La champ \textit{exectime} de cette structure nous permet d'obtenir le temps d'exécution de la tâche depuis son lancement (donc il y a certainement eu plusieurs occurrences). On appelle ce temps \textit{begin}. Ce qu'on veut, c'est simuler le temps d'\textbf{une} exécution de la tâche.

Pour cela, on va, dans une boucle, vérifier la différence entre le temps d'exécution actuel de la tâche (avec le champ \textit{exectime} de RT\_TASK\_INFO mis à jour) et le temps d'exécution de la tâche initial (qu'on a appelé \textit{begin}). Dès que cette différence atteint la durée voulue (durée d'exécution de la tâche donnée en paramètre), on peut sortir de la boucle et de la fonction. De cette façon, on a réalisé une attente active pendant la durée recherchée.

\subsection{Question 4}

On se sert de la fonction time\_since\_start dans la fonction rt\_task pour avoir un point de repère temporel :

\begin{lstlisting}
rt_printf("doing %s    time : %d\n",rt_task_name(), time_since_start());
\end{lstlisting}

\newpage
Voici le résultat de l'exécution du programme :

\begin{figure}[h]
	\centering
		\includegraphics[width=0.8\textwidth]{screenstp8/4.png}
		\caption{Résultat avec ORDO\_BUS}
\end{figure}

Le timing est bon : 25ms d'exécution et 125ms de période.

\subsection{Question 5}

Pour une bonne coordination des tâches, le sémaphore doit être utilisé comme suit :
\begin{itemize}
\item Faire un sem\_p (-1) dans acquire\_resource et un sem\_v (+1) dans release\_resource sur le sémaphore
\item Initialisation du sémaphore à 0 (bloque tout)
\item Initialisation de toutes les tâches (et donc toutes les tâches sont bloquées)
\item Faire un sem\_v (+1) sur le sémaphore juste après ces initialisations (ce qui débloquera la tâche la plus prioritaire)
\end{itemize}

De cette façon, les tâches s'enchaîneront de la bonne manière selon leurs priorités.

\begin{figure}[h]
	\centering
		\includegraphics[width=0.4\textwidth]{screenstp8/51.png}
		\caption{Enchaînement avec meilleur cas pour METEO (40ms)}
\end{figure}

\begin{figure}[h]
	\centering
		\includegraphics[width=0.4\textwidth]{screenstp8/52.png}
		\caption{Enchaînement avec pire cas pour METEO (60ms)}
\end{figure}
\newpage
On se rend compte que, lors du meilleur cas pour la tâche METEO (soit 40ms), ORDO\_BUS n'a pas encore terminé sa période et n'est donc pas prêt pour exécution avant le début de la tâche PILOTAGE ou la fin de DISTRIB\_DONNEES. Dans le pire cas pour la tâche METEO (soit 60ms),  ORDO\_BUS a atteint sa période et est donc exécuté avant la tâche PILOTAGE et s'intercale entre le début et le fin de l'exécution de DISTRIB\_DONNEES.
\newpage
\subsection{Question 6}


\appendix
\chapter{Messages de sortie du terminal entre l'allumage de la cible et le prompt de login}
\begin{lstlisting}[caption=Messages de sortie du terminal entre l'allumage de la cible et le prompt de login, label=message_sortie]
CCCCCCCC
U-Boot SPL 2011.09-svn (May 22 2012 - 11:19:00)
Texas Instruments Revision detection unimplemented
Booting from NAND...


U-Boot 2011.09-svn (May 22 2012 - 11:19:00)

I2C:   ready
DRAM:  512 MiB
WARNING: Caches not enabled
Did not find a recognized configuration, assuming General purpose EVM in Profile 0 with Daughter board
NAND:  HW ECC Hamming Code selected
512 MiB
MMC:   OMAP SD/MMC: 0
Net:   cpsw
Hit any key to stop autoboot:  3 \0x08\0x08\0x08 2 \0x08\0x08\0x08 1 \0x08\0x08\0x08 0 
Card did not respond to voltage select!
Booting from network ...
miiphy read id fail
link up on port 0, speed 100, full duplex
BOOTP broadcast 1
DHCP client bound to address 192.168.1.6
Using cpsw device
TFTP from server 192.168.1.1; our IP address is 192.168.1.6
Filename 'uImage'.
Load address: 0x82000000
Loading: *\0x08#################################################################
\0x09 #################################################################
\0x09 #################################################################
\0x09 #################################################################
\0x09 #################################################################
\0x09 #################################################################
\0x09 #################################################################
\0x09 #################################################################
\0x09 #################################################################
\0x09 ###########################################
done
Bytes transferred = 3215152 (310f30 hex)
## Booting kernel from Legacy Image at 82000000 ...
   Image Name:   Linux-3.1.0
   Image Type:   ARM Linux Kernel Image (uncompressed)
   Data Size:    3215088 Bytes = 3.1 MiB
   Load Address: 80008000
   Entry Point:  80008000
   Verifying Checksum ... OK
   Loading Kernel Image ... OK
OK

Starting kernel ...

Uncompressing Linux... done, booting the kernel.
Linux version 3.1.0 (mi11@mi11-VirtualBox) (gcc version 4.9.1 (GCC) ) #1 Mon Apr 10 18:15:11 CEST 2017
CPU: ARMv7 Processor [413fc082] revision 2 (ARMv7), cr=10c53c7d
CPU: VIPT nonaliasing data cache, VIPT aliasing instruction cache
Machine: am335xevm
Memory policy: ECC disabled, Data cache writeback
AM335X ES1.0 (neon )
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 130048
Kernel command line: console=ttyO0,115200n8 ip=dhcp noinitrd root=/dev/nfs rw rootwait
PID hash table entries: 2048 (order: 1, 8192 bytes)
Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)
Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)
Memory: 512MB = 512MB total
Memory: 512996k/512996k available, 11292k reserved, 0K highmem
Virtual kernel memory layout:
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
    DMA     : 0xffa00000 - 0xffe00000   (   4 MB)
    vmalloc : 0xe0800000 - 0xf8000000   ( 376 MB)
    lowmem  : 0xc0000000 - 0xe0000000   ( 512 MB)
    modules : 0xbf000000 - 0xc0000000   (  16 MB)
      .text : 0xc0008000 - 0xc05c6000   (5880 kB)
      .init : 0xc05c6000 - 0xc05ff000   ( 228 kB)
      .data : 0xc0600000 - 0xc065e618   ( 378 kB)
       .bss : 0xc065e63c - 0xc0699694   ( 237 kB)
NR_IRQS:396
IRQ: Found an INTC at 0xfa200000 (revision 5.0) with 128 interrupts
Total of 128 interrupts on 1 active controller
OMAP clockevent source: GPTIMER1 at 25000000 Hz
OMAP clocksource: GPTIMER2 at 25000000 Hz
sched_clock: 32 bits at 25MHz, resolution 40ns, wraps every 171798ms
Console: colour dummy device 80x30
Calibrating delay loop... 718.02 BogoMIPS (lpj=3590144)
pid_max: default: 32768 minimum: 301
Security Framework initialized
Mount-cache hash table entries: 512
CPU: Testing write buffer coherency: ok
devtmpfs: initialized
print_constraints: dummy: 
NET: Registered protocol family 16
GPMC revision 6.0
OMAP GPIO hardware version 0.1
omap_l3_smx omap_l3_smx.0: couldn't find resource
omap_mux_init: Add partition: #1: core, flags: 0
 omap_i2c.1: alias fck already exists
The board is general purpose EVM in profile 0
 omap_hsmmc.0: alias fck already exists
 omap_hsmmc.2: alias fck already exists
Configure Bluetooth Enable pin...
error setting wl12xx data
 omap2_mcspi.1: alias fck already exists
 omap2_mcspi.2: alias fck already exists
bio: create slab <bio-0> at 0
SCSI subsystem initialized
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
registerd cppi-dma Intr @ IRQ 17
Cppi41 Init Done Qmgr-base(e083a000) dma-base(e0838000)
Cppi41 Init Done
omap_i2c omap_i2c.1: bus 1 rev4.0 at 100 kHz
Advanced Linux Sound Architecture Driver Version 1.0.24.
Bluetooth: Core ver 2.16
NET: Registered protocol family 31
Bluetooth: HCI device and connection manager initialized
Bluetooth: HCI socket layer initialized
Bluetooth: L2CAP socket layer initialized
Bluetooth: SCO socket layer initialized
Switching to clocksource gp timer
Switched to NOHz mode on CPU #0
musb-hdrc: version 6.0, ?dma?, otg (peripheral+host)
musb-hdrc musb-hdrc.0: dma type: dma-cppi41
musb-hdrc musb-hdrc.0: USB OTG mode controller at e080a000 using DMA, IRQ 18
musb-hdrc musb-hdrc.1: dma type: dma-cppi41
musb-hdrc musb-hdrc.1: USB OTG mode controller at e080c800 using DMA, IRQ 19
NET: Registered protocol family 2
IP route cache hash table entries: 4096 (order: 2, 16384 bytes)
TCP established hash table entries: 16384 (order: 5, 131072 bytes)
TCP bind hash table entries: 16384 (order: 4, 65536 bytes)
TCP: Hash tables configured (established 16384 bind 16384)
TCP reno registered
UDP hash table entries: 256 (order: 0, 4096 bytes)
UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
NET: Registered protocol family 1
RPC: Registered named UNIX socket transport module.
RPC: Registered udp transport module.
RPC: Registered tcp transport module.
RPC: Registered tcp NFSv4.1 backchannel transport module.
NetWinder Floating Point Emulator V0.97 (double precision)
VFS: Disk quotas dquot_6.5.2
Dquot-cache hash table entries: 1024 (order 0, 4096 bytes)
JFFS2 version 2.2. (NAND) (SUMMARY)  \0xc2\0xa9 2001-2006 Red Hat, Inc.
msgmni has been set to 1001
io scheduler noop registered
io scheduler deadline registered
io scheduler cfq registered (default)
Could not set LED4 to fully on
da8xx_lcdc da8xx_lcdc.0: GLCD: Found AT043TN24 panel
Console: switching to colour frame buffer device 60x34
Serial: 8250/16550 driver, 4 ports, IRQ sharing enabled
omap_uart.0: ttyO0 at MMIO 0x44e09000 (irq = 72) is a OMAP UART0
console [ttyO0] enabled
omap_uart.1: ttyO1 at MMIO 0x48022000 (irq = 73) is a OMAP UART1
omap_uart.2: ttyO2 at MMIO 0x48024000 (irq = 74) is a OMAP UART2
omap_uart.3: ttyO3 at MMIO 0x481a6000 (irq = 44) is a OMAP UART3
omap_uart.4: ttyO4 at MMIO 0x481a8000 (irq = 45) is a OMAP UART4
omap_uart.5: ttyO5 at MMIO 0x481aa000 (irq = 46) is a OMAP UART5
brd: module loaded
loop: module loaded
i2c-core: driver [tsl2550] using legacy suspend method
i2c-core: driver [tsl2550] using legacy resume method
mtdoops: mtd device (mtddev=name/number) must be supplied
omap2-nand driver initializing
ONFI flash detected
ONFI param page 0 valid
NAND device: Manufacturer ID: 0xad, Chip ID: 0xdc (Hynix H27U4G8F2DTR-BC)
Creating 8 MTD partitions on "omap2-nand.0":
0x000000000000-0x000000020000 : "SPL"
0x000000020000-0x000000040000 : "SPL.backup1"
0x000000040000-0x000000060000 : "SPL.backup2"
0x000000060000-0x000000080000 : "SPL.backup3"
0x000000080000-0x000000260000 : "U-Boot"
0x000000260000-0x000000280000 : "U-Boot Env"
0x000000280000-0x000000780000 : "Kernel"
0x000000780000-0x000020000000 : "File System"
OneNAND driver initializing
davinci_mdio davinci_mdio.0: davinci mdio revision 1.6
davinci_mdio davinci_mdio.0: detected phy mask ffffffef
davinci_mdio.0: probed
davinci_mdio davinci_mdio.0: phy[4]: device 0:04, driver unknown
CAN device driver interface
CAN bus driver for Bosch D_CAN controller 1.0
d_can d_can: d_can device registered (irq=55, irq_obj=56)
usbcore: registered new interface driver cdc_ether
usbcore: registered new interface driver cdc_subset
Initializing USB Mass Storage driver...
usbcore: registered new interface driver usb-storage
USB Mass Storage support registered.
 gadget: using random self ethernet address
 gadget: using random host ethernet address
usb0: MAC 06:50:55:8c:0c:93
usb0: HOST MAC 62:9a:93:a2:1e:53
 gadget: Ethernet Gadget, version: Memorial Day 2008
 gadget: g_ether ready
musb-hdrc musb-hdrc.0: MUSB HDRC host driver
musb-hdrc musb-hdrc.0: new USB bus registered, assigned bus number 1
usb usb1: New USB device found, idVendor=1d6b, idProduct=0002
usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb1: Product: MUSB HDRC host driver
usb usb1: Manufacturer: Linux 3.1.0 musb-hcd
usb usb1: SerialNumber: musb-hdrc.0
hub 1-0:1.0: USB hub found
hub 1-0:1.0: 1 port detected
musb-hdrc musb-hdrc.1: MUSB HDRC host driver
musb-hdrc musb-hdrc.1: new USB bus registered, assigned bus number 2
usb usb2: New USB device found, idVendor=1d6b, idProduct=0002
usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb2: Product: MUSB HDRC host driver
usb usb2: Manufacturer: Linux 3.1.0 musb-hcd
usb usb2: SerialNumber: musb-hdrc.1
hub 2-0:1.0: USB hub found
hub 2-0:1.0: 1 port detected
mousedev: PS/2 mouse device common for all mice
input: ti-tsc-adcc as /devices/platform/tsc/input/input0
omap_rtc omap_rtc: rtc core: registered omap_rtc as rtc0
i2c /dev entries driver
Linux video capture interface: v2.00
usbcore: registered new interface driver uvcvideo
USB Video Class driver (1.1.1)
OMAP Watchdog Timer Rev 0x01: initial timeout 60 sec
Bluetooth: HCI UART driver ver 2.2
Bluetooth: HCI H4 protocol initialized
Bluetooth: HCI BCSP protocol initialized
Bluetooth: HCILL protocol initialized
Bluetooth: HCIATH3K protocol initialized
cpuidle: using governor ladder
cpuidle: using governor menu
usbcore: registered new interface driver usbhid
usbhid: USB HID core driver
usbcore: registered new interface driver snd-usb-audio
_regulator_get: 1-000a supply VDDA not found, using dummy regulator
_regulator_get: 1-000a supply VDDIO not found, using dummy regulator
_regulator_get: 1-000a supply VDDD not found, using dummy regulator
sgtl5000 1-000a: sgtl5000 revision 17
print_constraints: 1-000a: 850 <--> 1600 mV at 1200 mV normal 
_regulator_get: 1-000a supply VDDA not found, using dummy regulator
_regulator_get: 1-000a supply VDDIO not found, using dummy regulator
sgtl5000 1-000a: Using internal LDO instead of VDDD
mmc1: card claims to support voltages below the defined range. These will be ignored.
sgtl5000 1-000a: Failed to add route HPLOUT->Headphone Jack
sgtl5000 1-000a: dapm: unknown pin MONO_LOUT
sgtl5000 1-000a: dapm: unknown pin HPLCOM
sgtl5000 1-000a: dapm: unknown pin HPRCOM
asoc: sgtl5000 <-> davinci-mcasp.0 mapping ok
ALSA device list:
  #0: AM335X EVM
oprofile: hardware counters not available
oprofile: using timer interrupt.
nf_conntrack version 0.5.0 (8015 buckets, 32060 max)
ip_tables: (C) 2000-2006 Netfilter Core Team
TCP cubic registered
NET: Registered protocol family 17
can: controller area network core (rev 20090105 abi 8)
NET: Registered protocol family 29
can: raw protocol (rev 20090105)
can: broadcast manager protocol (rev 20090105 t)
Bluetooth: RFCOMM TTY layer initialized
Bluetooth: RFCOMM socket layer initialized
Bluetooth: RFCOMM ver 1.11
Bluetooth: BNEP (Ethernet Emulation) ver 1.3
Bluetooth: BNEP filters: protocol multicast
Bluetooth: HIDP (Human Interface Emulation) ver 1.2
Registering the dns_resolver key type
VFP support v0.3: implementor 41 architecture 3 part 30 variant c rev 3
ThumbEE CPU extension supported.
_regulator_get: mpu.0 supply mpu not found, using dummy regulator
omap2_set_init_voltage: Fail set voltage-dpll_mpu_ck(f=720000000 v=1260000)on vddmpu
omap2_set_init_voltage: unable to set vdd_mpu
Detected MACID=0:18:30:fe:7b:f6
input: gpio-keys as /devices/platform/gpio-keys/input/input1
omap_rtc omap_rtc: setting system clock to 2000-01-01 00:00:00 UTC (946684800)
mmc1: queuing unknown CIS tuple 0x91 (3 bytes)

CPSW phy found : id is : 0x4dd072
PHY 0:01 not found
mmc1: new SDIO card at address 0001
PHY: 0:04 - Link is Up - 100/Full
Sending DHCP requests ., OK
IP-Config: Got DHCP answer from 192.168.1.1, my address is 192.168.1.6
IP-Config: Complete:
     device=eth0, addr=192.168.1.6, mask=255.255.255.0, gw=255.255.255.255,
     host=192.168.1.6, domain=, nis-domain=(none),
     bootserver=192.168.1.1, rootserver=192.168.1.1, rootpath=/tftpboot/rootfs
VFS: Mounted root (nfs filesystem) on device 0:15.
devtmpfs: mounted
Freeing init memory: 228K

INIT: version 2.88 booting

Starting udev
udevd[718]: starting version 182
bootlogd: cannot allocate pseudo tty: No such file or directory
Populating dev cache
Fri Apr 14 13:12:58 UTC 2017

INIT: Entering runlevel: 5

Configuring network interfaces... ifup skipped for nfsroot interface eth0
run-parts: /etc/network/if-pre-up.d/nfsroot exited with code 1
Starting system message bus: dbus.
Starting Dropbear SSH server: Generating key, this may take a while...
Public key portion is:
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHQW67zEKPRIeKx6VZxLER0R/2HThSN/SWD3fMk23eXy9j3PudyVMJfjGBF258qnZNicoMsK0Mx5JrpV124XKCzvKTAYsMjLc67WdqcX73zSzt1Cplk99ATrT3SKK+Dq16Nld2ZuhfGDidLPvrSqOfRaUYRH6048XV/E7penoQ8oP2tJV0kiGnXRQMoqSyLyZFWW/0xNzatB/Wr6o+I7Iboc2KWDyOu8caJxP4fxrV/4zEjyTvSQCBCzwuv2RSFPJV7lleMD2XkKN+QOGCgG1Eq8TgrNDU0Jps+RelENrtkj+lgVJF2odabmPMtmsB+8lhtgdgk8wth0dbjQzedRFt root@devkit8600
Fingerprint: md5 a7:0c:a2:b1:07:9a:77:98:01:7e:31:13:10:02:42:2c
dropbear.
Starting rpcbind daemon...rpcbind: cannot create socket for udp6

rpcbind: cannot create socket for tcp6

done.
Starting syslogd/klogd: done
 * Starting Avahi mDNS/DNS-SD Daemon: avahi-daemon
   ...done.
Starting Telephony daemon
Starting Linux NFC daemon
/etc/rc5.d/S64neard: line 26: /usr/lib/neard/nfc/neard: No such file or directory


Poky (Yocto Project Reference Distro) 1.7.3 devkit8600 /dev/ttyO0



devkit8600 login: root
root@devkit8600:~# 
\end{lstlisting}



\end{document}

